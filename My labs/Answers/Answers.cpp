Билет 1
1.	Тип данных присваивается переменной при ее объявлении или инициализации.
Основные типы данных :
•	Int – целочисленный тип данных
•	Float – тип данных с плавающей точкой
•	Double – тип данных с плавающей точкой двойной точности
•	Char – символьный тип данных
•	Bool - логический тип данных.
Объявление переменных : *тип данных* *переменная*.
Инициализация переменных : *тип данных* *переменная* = *значение*.
Объявление констант : const *тип данных* *переменная* = *значение*.
Назначение типов данных – 3.0 и 3 будут по - разному восприниматься компьютером.Каждый тип данных кодируется по - своему.
2.	1) Не знаю.
2) Инициализация:
•	Десятичные : последовательность любых цифр, которые начинаются не с нуля
•	Шестнадцатеричные : присутствует префикс 0х
•	Двоичные : нет возможности инициализировать число в двоичной записи ? 0b
•	Восьмеричные : префикс 0.
3.	В машинной записи числа со знаком минус выделяется отдельный бит для записи знака, в то время, для плюса не выделяется такого бита, ибо он представляет собой незначащий 0 в машинной записи.
Сложение и вычитание беззнаковых чисел происходит по обычным для позиционных систем счисления алгоритмам.
В скобках система счисления.
001(2) + 100(2) = 101(2);
101(2) - 010(2) = 011(2).
Обратный код получается инвертированием всех цифр двоичного кода, включая разряд знака, нули меняем на единицы, а единицы на нули.Дополнительный код получается образованием обратного кода с последующим прибавлением единицы к его младшему разряду.Это наиболее популярные способы представления отрицательных чисел в компьютерах.
Билет 2
1.	Массив – это область памяти, где последовательно хранятся несколько значений.Массив предназначен для нумерованного хранения однотипных данных.
Объявление массива : *тип* *имя* *[размер] * = *{ инициализация }*-одномерный,
*тип* *имя* *[размер] * *[размер] * = *{ инициализация }*-двумерный итд.
Синтаксис доступа к элементу : *имя массива* *[номер элемента] * .
2.	Для хранения одномерного массива в памяти выделяется несколько подряд идущих ячеек для его элементов.Для хранения двумерного массива образуется матрица ячеек памяти для его элементов.
Инициализация массива одним числом, вроде работает только с нулем, происходит таким образом int array[10] = { 0 }.
3.	НЕ ЗНАЮ
Билет 3
1.	Операторы цикла :
•	for (счетчик = значение; счетчик < значение; шаг цикла) { тело цикла; }
•	while (условие) { тело цикла; }
•	do { тело цикла; } while (условие).Сначала выполняется тело цикла, а затем проверяется условие.
Операторы условного перехода :
•	if (условие) { оператор1; }
else { оператор2; }
•	switch (выражение)
{
case значение1: операторы1; break
case значение2: операторы2; break…
default: операторы; break;
}
Break необходим для того, чтобы выйти из switch, если его не будет, то будут выполняться следующие операторы.
Default действует по принципу else.
2.	Оператор break приводит к завершению выполнения циклов do, for, switch или while.В контексте оператора switch break обычно используется в конце каждого кейса для его завершения.В контексте циклов оператор break используется для завершения работы цикла раньше времени.
Оператор continue позволяет сразу перейти в конец тела цикла, пропуская весь код, который находится под ним.Это полезно в тех случаях, когда мы хотим завершить текущую итерацию раньше времени.
Тернарный оператор.УСЛОВИЕ ? КОМАНДА1 : КОМАНДА2.Используется он обычно в тех случаях, если условие и код, который надо выполнить, в результате проверки условия, очень простые.Упрощает работу со ссылками.
НЕ СРАБОТАЕТ
int& i;
if (some_condition)
i = a;
else i = b;
СРАБОТАЕТ
int& i = (some_condition ? a : b);
3.	НЕ ЗНАЮ.
Билет 4
1.	Функции позволяют сделать программу модульной, то есть разделить программу на несколько маленьких функций.Еще один огромнейший плюс функций в том, что их можно многократно использовать.Данная возможность позволяет многократно использовать один раз написанный код, что в свою очередь, намного сокращает объем кода программы.
void *имя функции* (*параметры функции*)
{
	тело функции;
}
Объявление
int sum(int num1, int num2); например, делаем в классе.

Определение
int sum(int num1, int num2)
{
	return (num1 + num2);
} Описываем тело функции.

Вызов функции.Пишем имя функции и передаваемые аргументы в скобках.
sum(а, b)
2.	При передаче аргумента по ссылке является более эффективной, поскольку функция использует сам объект, а не его значение.При выполнении функции будет изменяться значение объекта не только в пределах функции, а в пределах всей программы.
При выполнении функции, аргументы которой были переданы по значению, будут изменяться только в пределах функции.
Если что, вот https ://metanit.com/cpp/tutorial/3.3.php
3.	Дико сложно, думаю, не стоит ломать голову.
Билет 5
Обозначения :
	&-адрес
	* -указатель
	Определения и синтаксис :
1) функция - фрагмент кода, имеющий собственный идентификатор, а также интерфейс(набор входных и выходных параметров)
2) тело функции - список операторов, которые выполняются в функции
3) заголовок функции - имя и список параметров, перечисленных по правилу языка .
4) объявление функции - фактически, один заголовок без темы, который приводится в коде, чтобы компилятор знал как выглядит функция
5) Определение - заголовок + тело
Билет 6
Классы в С++ — это абстракция описывающая методы, свойства, ещё не существующих объектов.Объекты — конкретное представление абстракции, имеющее свои свойства и методы.
Классы объявляем до main.Синтаксис:
class [имя класса]
{
private:
	/* доступ открыт самому классу (т.е. функциям-членам данного класса) и друзьям (friend) данного класса - как функциям, так и классам. Обычно прописывает свойства */
public:
	/* доступ открыт всем, кто видит определение данного класса. Обычно прописываем методы */
protected:
	/* доступ открыт классам, производным от данного (наследование). То есть, производные классы получают свободный доступ к таким свойствам или метода. Все другие классы такого доступа не имеют */
};
Объект объявляем в main.Синтаксис:
[имя класса] [имя объекта];
Вызов методов происходит в main.Синтаксис:
[имя объекта].[метод];
Классы имеют свои функции, которые называются методами класса.Передвижение велосипеда осуществляется за счёт вращения педалей, если рассматривать велосипед с точки зрения ООП, то механизм вращения педалей — это метод класса.
Наследование классов — очень мощная возможность в объектно ориентированном программировании.Оно позволяет создавать производные классы(классы наследники), взяв за основу все методы и элементы базового класса(класса родителя).Таким образом экономится масса времени на написание и отладку кода новой программы.Объекты производного класса свободно могут использовать всё, что создано и отлажено в базовом классе.
Синтаксис наследования :
class[имя класса наследника] : [модификатор доступа] [имя класса родителя]{
};
Конструктор – это специальный метод класса, который предназначен для инициализации элементов класса некоторыми начальными значениями.
Деструктор  — специальный метод класса, который служит для уничтожения элементов класса.Чаще всего его используют тогда, когда в конструкторе при создании объекта класса динамически был выделен участок памяти и необходимо эту память очистить, если эти значения уже не нужны для дальнейшей работы программы.
Конструктор и деструктор всегда объявляем в разделе public.В классе допустимо создавать несколько конструкторов, если это необходимо.Деструктор всегда один.
Синтаксис конструктора и деструктора :
[имя класса](); //конструктор
~[имя класса](); //деструктор
Множественное наследование - один класс может наследовать атрибуты двух и более классов одновременно.Для этого используется список базовых классов, в котором каждый из базовых классов отделен от других запятой.
Синтаксис множественного наследования :
class[имя класса наследника] : [модификатор доступа] [имя класса родителя], [модификатор доступа][имя класса родителя], …, [модификатор доступа][имя класса родителя]{
};
Указатель this — это указатель на адрес объекта класса, при этом он является скрытым первым параметром любого метода класса(кроме статических методов), а типом указателя выступает имя класса.Мы можем использовать this явно в методах - элементах класса.
Билет 7
В библиотеках содержатся наборы функций и классов.Они нужны для того, чтобы наш код был менее сложным и большим.Легче сослаться из разных проектов на одну библиотеку, в которой содержатся функции, чем переписывать в каждый проект их работу.
Существуют библиотеки с открытым кодом - исходный код таких программ доступен для просмотра, изучения и изменения, что позволяет пользователю принять участие в доработке самой открытой программы, использовать код для создания новых программ и исправления в них ошибок.Примеры библиотек с открытым кодом : Haru(для создания PDF - файла, написанного на ANSI - C), OpenCV(библиотека алгоритмов компьютерного зрения, обработки изображений и численных алгоритмов общего назначения), OpenSLL(полноценная криптографическая библиотека).
Типы связывания : статическое(СС) и динамическое(ДС).Статическое связывание происходит во время компиляции, из - за этого объём исполняемого файлы увеличивается, зато работает быстро.Динамическое связывание происходит на этапе выполнения код, поэтому объем исполняемого файла меньше, а работа кода более медленная, в отличии от СС.
Статическая библиотека имеет расширение *.lib.В заголовочных файлах(*.h/*.hpp) прописывается объявление методов. А в исходных файлах (*.c/*.cpp) прописывается реализация данных методов.
Динамическая библиотека имеет расширение *.dll.
Неявное связывание, или связывание во время загрузки: Сначала осуществляется сборка DLL. В процессе сборки создается библиотечный .LIB-файл, играющий роль заглушки (stub) для фактического кода. Этот файл должен помещаться в каталог библиотек общего пользования, указанный в проекте. Также создается .DLL-файл, содержащий исполняемый модуль. В типичных случаях этот файл размещается в том же каталоге, что и приложение, которое будет его использовать, и приложение загружает DLL в процессе своей инициализации. (Вторым возможным местом расположения DLL является рабочий каталог, а далее ОС будет осуществлять поиск .DLL-файла в системном каталоге, каталоге Windows).
Явное связывание, или связывание во время выполнения (run-time linking), требует, чтобы в программе содержались конкретные указания относительно того, когда именно необходимо загрузить или освободить библиотеку DLL. Далее программа получает адрес запрошенной точки входа и использует этот адрес в качестве указателя при вызове функции. В вызывающей программе
функция не объявляется; вместо этого в качестве указателя на функцию объявляется переменная. Поэтому во время компоновки программы присутствие библиотеки не является обязательным. Для выполнения необходимых операций требуются три функции: LoadLibrary (или LoadLibraryEx) [служат для загрузки библиотек], GetProcAddress [для получения адреса любой точки входа после загрузки библиотеки, но до ее освобождения] и FreeLibrary [выгрузка библиотеки из памяти].
Билет 8
Перегрузка - это объявление нескольких функций (методов классов и операторов, которые тоже являются функциями) с одинаковыми именами, но разным набором аргументов. Если функции различаются только по выходному параметру, то это не перегрузка.
Перегрузка нужна для того, чтобы одним и тем же методом было возможно обрабатывать разные типы данных, а также существует перегрузка операторов, с помощью которой можно "объяснить" как, например, складывать или выводить ваш собственный тип данных (класс).
Синтаксис перегрузки: operator@ [где @ это идентификатор оператора (например +, -, <<, >>)]; & - для обозначения места, где стоит тип данных в выражениях; *this - это указатель, который указывает на объект, владеющий функцией.
Примеры: friend std::istream &operator >> (std::istream &cn, Matrica &A)
Matrica & operator=(Matrica F) []
Принцип работы: 1) компилятор ищет точные совпадения типов аргументов, если не нашёл:
2) Он пытается использовать приведение типов и снова ищет совпадения, если не нашёл: 3) Использует стандартные преобразования типов. И если вновь не находит - выдаёт ошибку.
При перегрузке может возникнуть неоднозначность.
Бинарный оператор - это функция от двух параметров, параметрами которой являются левый и правый операнды оператора.
Matrica operator+(Matrica F) {
Matrica Summ;
if (F.strok == strok && F.stolb == stolb) {
Summ.create(strok, stolb);
for (int a = 0; a < F.strok; a++) {
for (int b = 0; b < F.stolb; b++) {

Summ.matrix[a*stolb + b] = give(a, b) + F.give(a, b);
}
}
}
return Summ;
}
Унарный оператор - это оператор от одного параметра. Если он объявлен внутри класса, то этим параметром (неявным) является this.
Matrica & operator=(Matrica F) {
delete[] matrix;
matrix = new int[F.strok*F.stolb];
for (int a = 0; a < F.strok; a++) {
for (int b = 0; b < F.stolb; b++) {
matrix[a*F.stolb + b] = F.matrix[a*F.stolb + b];
}
}
strok = F.strok;
stolb = F.stolb;
return *this;
}

Билет 9
Шаблоны функций, своими словами,— это инструкции, согласно которым создаются локальные версии шаблонированной функции для определенного набора параметров и типов данных.
// шаблон функции printArray
template <typename T>
void printArray(const T * array, int count)
{
for (int ix = 0; ix < count; ix++)
cout << array[ix] << " ";
cout << endl;
} // конец шаблона функции printArray
Все шаблоны функций начинаются со слова template, после которого идут угловые скобки, в которых перечисляется список параметров. Каждому параметру должно предшествовать зарезервированное слово class или typename.
1 template <class T>
или
1 template <typename T>
или
1 template <typename T1, typename T2>
Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип данных, такой как: int, double, float, char и т. д. А ключевое слово class сообщает компилятору, что в шаблоне функции в качестве параметра будут использоваться пользовательские типы данных, то есть классы.
Если нам надо создать шаблон класса, с одним параметром типа int и char, шаблон класса будет выглядеть так:
template <typename T> class Name { //тело шаблона класса };
где T — это параметр шаблона класса, который может принимать любой из встроенных типов данных, то, что нам и нужно.
А если параметр шаблона класса должен пользовательского типа, например типа Array, где Array — это класс, описывающий массив, шаблон класса будет иметь следующий вид
template <class T> class Name { //тело шаблона класса };

Билет 11
Строки подключаются так:
#include <cstring> - для С
#include <string> - для С++
Объявление:
std::string Имя_переменной = " ";
Методы:
В С:
strcat() - объединение строк
strlen() - длинна строки
strcmp() - сравнение строк
scanf() - считывать строки
strcpy() - копирование из 1ой строки в другую
В С++:
= = - сравнение
std.string.length() - длинна
+ - объединение строк
= - копирование
Имя_переменной.find_first_of(" ") - ищет место первого появления символа
Имя_переменной.find_last_of(" ") - ищет место последнего появления символа
Билет 12
Файлы позволяют пользователю считывать большие объемы данных непосредственно с диска, не вводя их с клавиатуры. Существуют два основных типа файлов: текстовые и двоичные.
Текстовыми называются файлы, состоящие из любых символов. Они организуются по строкам, каждая из которых заканчивается символом «конца строки» - \0. Конец самого файла обозначается символом «конца файла» - eof. При записи информации в текстовый файл, просмотреть который можно с помощью любого текстового редактора, все данные преобразуются к символьному типу и хранятся в символьном виде.
В двоичных файлах информация считывается и записывается в виде блоков определенного размера, в которых могут храниться данные любого вида и структуры.
C++
Для работы с файлами используются специальные типы данных, называемые потоками. Поток ifstream служит для работы с файлами в режиме чтения, а ofstream в режиме записи. Для работы с файлами в режиме как записи, так и чтения служит поток fstream.
В программах на C++ при работе с текстовыми файлами необходимо подключать библиотеки iostream и fstream.
Для того чтобы записывать данные в текстовый файл, необходимо:
1. описать переменную типа ofstream.
2. открыть файл с помощью функции open.
3. вывести информацию в файл.
4. обязательно закрыть файл.




Методы класса:

Для считывания данных из текстового файла, необходимо:
1. описать переменную типа ifstream.
2. открыть файл с помощью функции open.
3. считать информацию из файла, при считывании каждой порции данных необходимо проверять, достигнут ли конец файла.
4. закрыть файл.
Методы класса:


C
Файловая система языка С состоит из нескольких взаимосвязанных функций. Для их работы требуется заголовок <stdio.h>.
FILE *fopen(const char *имя_файла, const char *режим);
1. Сначала надо создать указатель на переменную типа FILE ( FILE* file; ).
2. Открытие файла производится вызовом функции fopen ( file = fopen( file_name, "w" ); )
3. Первый параметр этой функции - имя файла, второй - указывает в каком режиме должен быть открыт файл.
"w" - открыть для записи, "r" - открыть для чтения, "a" - дополнение файла( это наиболее используемые режимы, хотя есть и другие ):

3.	Запись и считывание данных из файла осуществляется следующими функциями : fputc, fputs, fgetc, fgets, fprintf, fscanf( описание этих функций смотрите в stdio.h):


4.	Закрытие файла осуществляется вызовом функции fclose ( fclose( file ); ).
Билет 13
Структура - это набор данных, где данные могут быть разного типа. Например, структура может содержать несколько переменных типа int и несколько переменных типа char. Переменные, которые содержаться в структуре называются членами или полями структуры. Структуры можно определять с помощью ключевого слова struct.
struct Employee // инициализация структуры
{
short id;
int age;
double salary;
};
Employee john;
john.id = 5;
john.age = 27;
john.salary = 45000.0;
Вектор — это структура данных, которая уже является моделью динамического массива.
Доступ к элементам производится по числовому индексу (обычно начиная с 0-го индекса, хотя есть и исключения), обычно доступ к элементу коллекции по индексу записывается как myFavoriteCats[i] или blackKitties[5]. Причем для обозначения этого самого числа — индекса используют букву i.
Далее — вектор — упорядоченная коллекция, что, собственно, понятно — у нас есть такие понятия как первый, последний элемент, для каждого конкретно взятого элемента мы также можем назвать предыдущий и следующий.
Такая реализация позволит получить Произвольный доступ к элементам осуществляется за постоянное время, но вставка и удаление ведет к накладным расходам, так как приходится выполнять сдвиг части массива, а еще выполнять перераспределение памяти.
Сначала для создания вектора нам понадобится подключить библиотеку — <vector>, в ней хранится шаблон вектора.
#include <vector>
Далее, чтобы объявить вектор, нужно пользоваться конструкцией ниже:
vector < тип данных > <имя вектора>;
Вот пример:
vector <int> ivector = {<элемент [0]>, <[1]>, <[2]>};
Обращение к вектору и изменения элемента
vector <int> ivector = {1, 2, 3};
ivector.at(1) = 5; // изменили значение второго элемента
cout << ivector.at(1); // вывели его на экран
Указание количества ячеек
vector <int> vector_first(5); указание длины вектора в начале программы, а так можно задавать откуда угодно
Так в круглых скобках () после имени вектора указываем первоначальную длину. А вот второй способ:
1 2 vector <int> vector_second; // создали вектор
vector_second.reserve(5); // указали число ячеек

Список (list).
Реализован как последовательность элементов с указателями, ссылающимися друг на друга, из-за этого вставка и удаление элементов в любом месте выполняются за постоянное и относительно небольшое время, а вот доступ к произвольным элементам получается дорогой, так как каждый раз приходится выполнять проход по списку с самого начала. Очень быстро работает удаление и добавление элемента в любом месте контейнера
Размер списка
Для получения размера списка можно использовать функцию size():
std::list<int> numbers = { 1, 2, 3, 4, 5 };
int size = numbers.size(); // 5
Функция empty() позволяет узнать, пуст ли список.
std::list<int> numbers = { 1, 2, 3, 4, 5 };
if (numbers.empty())
С помощью функции resize() можно изменить размер списка. Эта функция имеет две формы:
resize(n): оставляет в списке n первых элементов. Если список содержит больше элементов, то он усекается до первых n элементов. Если размер списка меньше n, то добавляются недостающие элементы и инициализируются значением по умолчанию
resize(n, value): также оставляет в списке n первых элементов. Если размер списка меньше n, то добавляются недостающие элементы со значением value
Изменение элементов списка
Функция assign() позволяет заменить все элементы списка определенным набором. Она имеет следующие формы:
assign(il): заменяет содержимое контейнера элементами из списка инициализации il
assign(n, value): заменяет содержимое контейнера n элементами, которые имеют значение value
assign(begin, end): заменяет содержимое контейнера элементами из диапазона, на начало и конец которого указывают итераторы begin и end
std::list<int> numbers = { 1, 2, 3, 4, 5 };
numbers.assign({ 21, 22, 23, 24, 25 }); // numbers = { 21, 22, 23, 24, 25 }
numbers.assign(4, 3); // numbers = {3, 3, 3, 3}
std::list<int> values = { 6, 7, 8, 9, 10, 11 };
auto start = ++values.begin(); // итератор указывает на второй элемент из values
auto end = values.end();
numbers.assign(start, end); // numbers = { 7, 8, 9, 10, 11 }
Функция swap() обменивает значениями два списка:
std::list<int> list1 = { 1, 2, 3, 4, 5 };
std::list<int> list2 = { 6, 7, 8, 9};
list1.swap(list2);
// list1 = { 6, 7, 8, 9};
// list2 = { 1, 2, 3, 4, 5 };
Добавление элементов
Для добавления элементов в контейнер list применяется ряд функций.
push_back(val): добавляет значение val в конец списка
push_front(val): добавляет значение val в начало списка
emplace_back(val): добавляет значение val в конец списка
emplace_front(val): добавляет значение val в начало списка
emplace(pos, val): вставляет элемент val на позицию, на которую указывает итератор pos. Возвращает итератор на добавленный элемент
insert(pos, val): вставляет элемент val на позицию, на которую указывает итератор pos, аналогично функции emplace. Возвращает итератор на добавленный элемент
insert(pos, n, val): вставляет n элементов val начиная с позиции, на которую указывает итератор pos. Возвращает итератор на первый добавленный элемент. Если n = 0, то возвращается итератор pos.
insert(pos, begin, end): вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end. Возвращает итератор на первый добавленный элемент. Если между итераторами begin и end нет элементов, то возвращается итератор pos.
insert(pos, values): вставляет список значений values начиная с позиции, на которую указывает итератор pos. Возвращает итератор на первый добавленный элемент. Если values не содержит элементов, то возвращается итератор pos.
Удаление элементов
Для удаления элементов из контейнера list могут применяться следующие функции:
clear(p): удаляет все элементы
pop_back(): удаляет последний элемент
pop_front(): удаляет первый элемент
erase(p): удаляет элемент, на который указывает итератор p. Возвращает итератор на элемент, следующий после удаленного, или на конец контейнера, если удален последний элемент
erase(begin, end): удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end. Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент.

Контейнер map, очень похож на остальные контейнеры, такие как vector, list, deque, но с небольшим отличием. В этот контейнер можно помещать сразу два значения. Если у Вас когда-то была мечта написать свой словарь, то лучше чем map, альтернативы не найти. И так, что же такое этот map, давай рассмотрим более подробнее на примере:
map <char,int> myFirstMap= {{ 'm', 37 },
												   { 'f'’, 40 },
												   { 'b', 15 },
												   { 's', 20 }};
Стек — это структура данных, которая работает по принципу(первый пришел — последний ушел)
В стеке элемент, который вошел самый первый — выйдет самым последним. Получается, если вы добавили три элемента в стек первым будет удален последний добавленный элемент.
Deque - структура данных совмещающая в себе функционал как очереди так и стека, элементы могут помещаться и извлекаться с обоих сторон очереди.
Пhи выполнении обращения к элементу по индексу массивы работают быстрее чем list за счет того, что вычисление адреса элемента в квадратных скобках выполняется простым сложением. Однако вставка или удаление элемента из массива приводят к сдвигу соседних с той или иной стороны/
ПОэтому вставка и удаление выполняется медленнее чем в list
Для программиста list обладает схожим интерфейсом и назнаечением ,что и array и vector,однако элементы лист по другому храняться в ОП и связанны между собой. list подобен цепочке,составленной из звеньев ,каждый элемент хранится в ОП как независимая переменная и связан с соседними парой указателей в следствии такого хранения элементов
1) доступ к элементу по индексу выполняется проходом по цепочке от нулевого элемента - операция ,намного более затратная ,чем в любом случае массива/вектора
2) однака вставка или удаления выполняется намного быстрее, чем в массиве векторе, особено чем больше элементов .
2.7 ) Словарь В случае если нужно хранить множество однотипных данных ,но связаны они не с номером/индексом , а с каким то нечисловым значением ,используется тип данных
Очередь - это структура данных ,которая построенна по принципу LILO(last in - last out: последний пришел - последним вышел). Примеры: очередь сообщений (каких-либо где-либо)
1) очередь отложенных сообщений в мессенджерах
2)Очередь команд в скриптововых языках
3)Очередь системных сообщений
Обьявление очереди:
std::queue<тип_данных> имя_переменной; Помещение данных в очередь: имя_стека.push(знаечение);
Извлеечение данных их очередь: переменная=имя_стека.pop();
Очередь с приоритетом - это обычная очередь, но в ней новый элемент добавляется в такое место, чтобы очередь была отсортирована по убываню.
















1. Типы данных. Назначение. Синтаксис объявления переменных и констант. 2. Занимаемый в памяти объём. Диапазоны целых чисел (в виде степени числа 2). Инициализация переменных и констант в десятичной, шестнадцатеричной, двоичной записи. 3. Машинная запись целых чисел со знаком. Целочисленная арифметика сложения и вычитания. Дополнительный и обратный код.

Тип данных Размер (в байтах) Диапазон

Bool 1 0…28

Int 4 -231…231-1

Char 1 -27…27-1

Long 4 -231…231-1

Short 2 -215…215-1

Float 4 1.17549e-38…3.40282e+38

double 8 2.22507e-308…1.79769e+308

Long long 8 -263…263-1

Тип данных присваивается переменной при ее объявлении или инициализации.

Объявление переменной: тип данных _ имя переменной.

Объявление констант: const_тип данных_имя переменной.

Инициализация переменной (когда объявляешь и присваиваешь значение одновременно).

Десятичная: int i=10;

Шестнадцатеричная: int i=0xA;

Двоичная: ХУЙ ЕГО ЗНАТЬ ─ В int, он уже пишется в двоичном формате.

В компьютере числа хранятся в двоичной записи. Целые числа со знаком хранятся в 8-ми, 16-ти, 32 разрядной сетке. Самый левый разряд (старший) содержит информацию о знаке числа. Если 0, то число положительное. Если 1, то ─ отрицательное.

Положительные числа в прямом, обратном и дополнительном кодах изображаются одинаково.

Прямой код: представление числа в двоичной системе.

Обратный код: конвертируем прямой код (нолики меняем на единички и наоборот)

Дополнительный код: к обратному коду добавляем 1.

В обратном или дополнительном коде в компьютере хранятся отрицательные числа, а при выводе обратно преобразуются в десятичные.

ЦЕЛОЧИСЛЕННАЯ АРИФМЕТИКА:

3.3.1.1 Сложение и вычитание чисел без знака Сложение и вычитание беззнаковых чисел происходит по обычным для позиционных систем счисления алгоритмам. Примеры (для k =3): 0012 +1002 = 1012; 1012 – 0102 = 0112. Ситуации, когда уменьшаемое меньше вычитаемого или когда результат суммы не умещается в k разрядов, считаются ошибочными и должны отслеживаться устройством компьютера. Реакция на такие ошибки может быть различной в разных типах компьютеров. 3.3.1.2 Сложение и вычитание чисел со знаком в обратном коде Сложение в обратном коде происходит следующим образом: по обычному алгоритму складываются все разряды, включая знаковый. Результат такого сложения для k-разрядных наборов имеет длину k +1 (самый левый разряд результата равен единице, если был перенос при сложении старших разрядов операндов, иначе – нулю). Значение левого k +1-го разряда добавляется к младшему разряду результата. Получаем k-разрядный набор, который и будет суммой двух чисел в обратном коде. Пример (k =3): +310 +(–110 ) = 0112+ 1102 = 1 0012 B 0012 +1 = 0102 = +210. Вычитание чисел в обратном коде x – y сводится к сложению x+ (–y). 3.3.1.3 Сложение и вычитание чисел со знаком в дополнительном коде В дополнительном коде сложение происходит так: по обычному алгоритму складываются все разряды, включая знаковый; единица переноса в k +1-й разряд отбрасывается (т.е. сложение по модулю 2k ). Пример (k =3): +310 +(–110) = 0112+ 1112 = 10102 B 0102 = +210. При вычитании тоже действует обычный алгоритм, причем если уменьшаемое меньше вычитаемого, к двоичному коду уменьшаемого слева приписывается единица -6- (т.е. добавляется 2k ) и только после этого производится вычитание (такой способ называется вычитание по модулю 2k ). Пример (k =3): 110 –3 10 = 0012 – 0112 B 10012 – 0112 = 1102 = –210.

2. Массивы. Назначение. Синтаксис объявления одномерных и многомерных массивов, и синтаксис доступа к элементу. Схема хранения одномерного и

двумерного массива неизменной длины в оперативной памяти. Инициализация массива целиком одним числом и инициализация отдельных элементов массива. Тип, который имеет имя массива (без скобок и индекса). Доступ к элементу массива через указатель и смещение.

Массив - блок из нескольких однотипных данных.

задавать массивом удобно

1. вектора и матрицы

2. множество точек из 3D и 2D

3. просто какой-либо числовой файл

4. строку - массив символов

5. видеобуфер (двумерный массив, соответствующий пикселам экрана)

Синтаксис объявления одномерных массивов:

тип_данных имя_массива [размер]

Синтаксис объявления многомерных массивов:

тип_данных имя_массива [размер1] [размер2] [размер3];

обращение к элементам массива: имя_массива [индекс]

Схема хранения одномерного и двумерного массива неизменной длины в оперативной памяти.

Элементы массива размещаются в памяти последовательно, друг за другом. Каждый элемент массива занимает столько памяти, сколько отводится под переменную, тип которой указан при описании массива.

В двумерном массиве под каждый элемент выделяется 2 ячейки памяти. Размещение в памяти осуществляется «снизу вверх». Элементы размещаются в порядке изменения индекса, что соответствует схеме вложенных циклов: сначала размещается первая строка, затем вторая, третья... Внутри строки по порядку идут элементы: первый, второй и т.д.

Инициализация массива целиком одним числом:

тип_данных имя_массива [размер]={значение_для_всех}

инициализация отдельных элементов массива:

тип_данных имя_массива [размер]= {значение1, значение2, значение3}

тип_данных имя_массива [размер1] [размер2] [размер3]==

{a11, a12, a13}

{a1, a22, a23}

{a31, a32, a33}

массивы в c++ нумеруются с нуля до (длина -1)

Тип, который имеет имя массива (без скобок и индекса).

std::array — это фиксированный массив, который не распадается в указатель при передаче в функцию. std::array определяется в заголовочном файле <array>, внутри пространства имен std.

Объявление такого массива: std::array<тип_данных, кол-во элементов> имя массива (std::array<int, 4> t)

Доступ к элементу массива через указатель и смещение.

фрагмент программы:

char str[80], *p1;

p1 = str;

Здесь p1 указывает на первый элемент массива str. Обратиться к пятому элементу массива str можно с помощью любого из двух выражений:

str[4]

* (p1+4)

3. Операторы цикла (3 разновидности) и условного перехода (2 разновидности). Синтаксис операторов. Операторы перехода на следующий цикл и прерывания цикла. Тернарный оператор. Нестандартные варианты синтаксиса for и while

Операторы цикла

Цикл с предусловием (while)

while ( выражение ) оператор Выражение определяет условие повторения тела цикла, представленного простым или составным оператором. Выполнение цикла начинается с вычисления выражения. Если оно истинно (не равно false), выполняется оператор цикла. Если при первой проверке выражение равно false, цикл не выполнится ни разу. Тип выражения должен быть арифметическим или приводимым к нему. Выражение вычисляется перед каждой

итерацией цикла. Когда выражение оказывается ложным, управление передается следующему после цикла оператору. Тело цикла может состоять не из одного оператора, а представлять собой блок. Пример (программа находит все делители целого положительного числа): int num; cout <<RUS( "\nВведите число : "); cin>> num; int div = 2; // кандидат на делитель while (div <= num) {if (!(num % div))cout << div <<"\n"; div++;} Цикл с постусловием (do … while) do оператор while (выражение) Сначала выполняется оператор или блок, составляющий тело цикла, а затем вычисляется выражение. Если оно истинно (не равно false), тело цикла выполняется еще раз. Цикл завершается, когда выражение станет равным false или в теле цикла будет выполнен какой-либо оператор передачи управления. Тип выражения должен быть арифметическим или приводимым к нему. Пример (программа осуществляет проверку ввода): char answer; do{cout << RUS("\nКупи слоника! "); cin >> answer; } while (answer != 'y'); Цикл с параметром for for ( инициализация; выражение; модификации) оператор; Инициализация используется для объявления и присвоения начальных значений величинам, используемым в цикле. В этой части можно записать не-сколько операторов, разделенных запятой (операцией «последовательное выполнение»), например, так: for (int i = 0, j = 2; ... или int k, m: for (k = 1, m = 0; ...

Операторы условного перехода

Условный оператор if

Для организации вычислений в зависимости от какого-либо условия в C++ предусмотрен условный оператор if, который в общем виде записывается следующим образом:

if (условие) оператор_1; else оператор_2;

Здесь условие — это логическое выражение, переменная или константа.

Работает условный оператор следующем образом. Сначала вычисляется значения выражения, записанного в виде условия. Если оно имеет значение истина (true), выполняется оператор_1. В противном случае (значение ложное (false) ) оператор_2.

Если в задаче требуется, чтобы в зависимости от значения условия выполнялся не один оператор, а несколько, их необходимо заключить в фигурные скобки, как составной оператор.

if (условие) { оператор_1; оператор_2; … }

else { оператор_1; оператор_2; … }

Альтернативная ветвь else в условном операторе может отсутствовать, если в ней нет необходимости.

Он необходим в тех случаях, когда в зависимости от значений переменной надо выполнить те или иные операторы:

switch (выражение) { case значение_1: операторы_1; break; case значение_2: операторы_2; break; … case значение_n: операторы_n; break; default: операторы; break; }

Оператор работает следующем образом. Вычисляется значение выражения. Затем выполняются операторы, помеченные значением, совпадающим со значением выражения. То есть если, выражение принимает значение_1, то

выполняются операторы_1 и т.д.. Если выражение не принимает ни одного из значений, то выполняются операторы, расположенные после слова default.

Оператор break необходим для того, чтобы осуществить выход из оператора switch. Если он не указан, то будут выполняться следующие операторы из списка, несмотря на то, что значение, которым они помечены, не совпадает со значением выражения.

Синтаксис операторов

* Пустой оператор – ;

Пустой оператор – это оператор, состоящий только из точки с запятой. Он может появиться в любом месте программы, где по синтаксису требуется оператор. Выполнение пустого оператора не меняет состояния программы.

* Составной оператор – {...}

Действие составного оператора состоит в последовательном выполнении содержащихся в нем операторов, за исключением тех случаев, когда какой-либо оператор явно передает управление в другое место программы.

* Оператор обработки исключений

* try { <операторы> }

* catch (<объявление исключения>) { <операторы> }

1. Операторы перехода на следующий цикл и прерывания цикла. Тернарный оператор. +

В теле любого цикла можно использовать операторы прерывания цикла - break и продолжения цикла - continue.

Оператор break позволяет выйти из цикла, не завершая его.

Оператор continue позволяет пропустить часть операторов тела цикла и начать новую итерацию.

Пример использования оператора continue:

for (int count=0; count < 20; ++count)

{

// если число делится нацело на 4, то пропускаем весь код в этой итерации после continue

if ((count % 4) == 0)

continue; // пропускаем всё и переходим в конец тела цикла

// Если число не делится нацело на 4, выполнение кода продолжается

cout << count << endl;

// Точка выполнение после оператора continue перемещается сюда

}

Пример использования оператора break:

for (int count = 0; count <= 10; count++) // начало цикла for

{

if ( count == 6) //

break; // выход из цикла for

cout << "2^" << count << " = " << pow(2.0,count) << endl; // печать степени двойки

}

Тернарный оператор.

Он используется обычно в тех случаях, если условие и код, который надо выполнить, в результате проверки условия, очень простые. К примеру, спросить у пользователя хочет он продолжить работать в программе или же хочет выйти из неё. Синтаксис такой:

"условие" ? "выражение 1" : "выражение 2";

Вначале надо записать необходимое нам условие и за ним поставить знак вопроса ? . Далее, в этой же строке, после знака вопроса пишем первую простую команду (код), которая будет выполняться, если условие вернет истину (true). После этой команды ставим двоеточие : и пишем вторую команду (код). Эта вторая команда после двоеточия, выполнится только в том случае, если условие возвращает ложь (false).

Пример использования тернарного оператора:

Допустим пользователь снимает деньги в банкомате. Он провел эту операцию и на экране должен появиться вопрос: “Вы хотите выполнить другую операцию?” Пользователю остается сделать выбор (да или нет) и нажать соответствующую кнопку. Организуем этот выбор в следующей программе:

bool variable = true;

cout << "Выполнение каких-то транзакций по счету карты...\n";

cout << "Вы хотите выполнить другую операцию (1 - да, 0 - нет)? ";

cin >> variable;

variable == 1 ? cout << "Выберите операцию!\n..........\n\n" : cout << "До свидания! Не забудьте взять чек!\n\n";

2. Нестандартные варианты синтаксиса for и while. +

Нестандартные возможности цикла for:

1) Применение нескольких переменных управления циклом.

int a, b;

for (a=0, b=9; a < 10; ++a, --b)

cout << a << " " << b << endl;

2) Отсутствие части цикла.

int count=0;

for ( ; count < 10; )

{

cout << count << " ";

++count;

}

3) Бесконечный цикл.

int main() {

int i = 0;

for (;;){

i++;

cout << i;

}

return 0;

}

Нестандартные возможности цикла while: 1) Бесконечный цикл.

int main() {

int i = 0;

while (true){

i++;

cout << i;

}

return 0;

}

4. Функция. Назначение. Синтаксис объявления, определения и вызова. Принцип работы функции. Передача параметров по ссылке и по значению. Стек, пролог и эпилог функции. Адрес возврата.

5. Указатель. Назначение. Синтаксис объявления указателя и доступа к данным, на которые ссылается указатель. Данные в динамической памяти. Синтаксис объявления и удаления. Объявление и удаление одномерных и многомерных массивов в динамической памяти. Сравнение особенностей хранения массивов статической длины и динамических массивов в оперативной памяти.

Указатель –переменная, хранящая адрес другой переменной в памяти.

Назначение. Все указатели всегда одной и той же разрядности (размера). Каким бы ни был огромным тип данных (строка, объект, массив) указатель на него всегда будет занимать 4/8 байт, что и является основным преимуществом указателей.

Синтаксис объявления указателя и доступа к данным, на которые ссылается указатель.

тип_данных * имя_указателя (int * ptr_a)

int *ptr_int = &a;

Оператор амперсенд & - оператор получения адреса.

Данные в динамической памяти. Динамическое выделение памяти необходимо для эффективного использования памяти компьютера. Например, мы написали какую-то программку, которая обрабатывает массив. При написании данной программы необходимо было объявить массив, то есть задать ему фиксированный размер (к примеру, от 0 до 100 элементов). Тогда данная программа будет не универсальной, ведь может обрабатывать массив размером не более 100 элементов. А если нам понадобятся всего 20 элементов, но в памяти выделится место под 100 элементов, ведь объявление массива было статическим, а такое использование памяти крайне неэффективно.

Преимущества:

1) доступно гораздо больше памяти, нежели в стеке (стек вызовов отслеживает все активные функции)

2) размеры массивов и структур данных можно определять и менять во время работы приложения

Особенность: для приложения, предназначенного для длительной работы, во избежание переполнения памяти созданные переменные и блоки памяти после использования должны быть освобождены с помощью оператора delete: delete имя_переменной.

Синтаксис объявления и удаления. Для использования свободной памяти ОС (heap - "куча" - отслеживает память, используемую для динамического выделения.)

объявляются динамические переменные по синтаксису:

указатель на тип имя переменной =new тип или тип*имя_переменной = new тип

удаление: delete имя_переменной

Объявление и удаление одномерных и многомерных массивов в динамической памяти.

Одномерные:

пара операторов new/delete - это одно из нововведений С++ относительно С

В динамической памяти могут выделяться только одномерные массивы

тип * имя_указатель = new тип [длина];

удаляются одномерные массивы с помощью записи

delete[] имя_указателя. (память возвращается обратно в кучу и затем может быть переназначена)

Многомерные:

для выделения двумерного массива сначала создаётся одномерный массив, содержащий указатели на другие массивы (строки)

МОЖЕМ ЗАДАВАТЬ РАЗМЕРНОСТИ ПЕРЕМЕННЫМИ

int ** dynamic2Darray = new int *[l1];

затем выделяется блок памяти под каждую строку и указатель на неё возвращается в созданный массив указателей

for (int i = 0; i < l1; i++)

{

dynamic2Darray[i] = new int[l2];

/dynamic2Darray[i] имеет тип (int*)/

for (int j = 0; j < l2; j++)

{ dynamic2Darray[i][j] = j; }

}

Сравнение особенностей хранения массивов статической длины и динамических массивов в оперативной памяти.

многомерные массивы фиксированной длины в стековой памяти чаще всего размещаются сплошным блоком

динамические - нет (где ОС выделила место под очередную строку - там она и будет находиться, и между строками будет неизвестно что)

6. Классы и объекты. Назначение. Синтаксис объявления, определения, доступа к свойствам и вызова методов. Модификаторы доступа. Конструктор и деструктор. Наследование. Назначение. Синтаксис. Множественное наследование. Указатель this и каким образом он передаётся в методы классов.

7. Библиотеки. Назначение. Примеры библиотек с открытым кодом. Типы связывания. Преимущества и недостатки различных типов. Статическое связывание. Неявное связывание динамических библиотек. Явное связывание динамических библиотек.

8. Перегрузка функций и методов. Назначение. Синтаксис перегрузки. Привести примеры. Принцип работы перегруженных функций и методов. Перегрузка унарных и бинарных операторов. Привести примеры.

Перегрузка функций и методов

Перегрузка (overloading) - объявление нескольких функций, а также методов классов и операторов, которые тоже являются функциями с одинаковыми именами, но с разным набором аргументов.

Назначение.

Перегрузка функций и методов используется, когда нужно сделать одно и то же действие с разными типами данных.

Синтаксис перегрузки:

Единственное условие – одинаковые имена.

Привести примеры

Перегрузка функции (было int стало double):

int max(int num1, int num2)

{

if (num1 > num2)

return num1;

return num2;

}

double max(double num1, double num2)

{

if (num1 > num2)

return num1;

return num2;

}

Перегрузка метода:

Double P (double a, double b, double c)

{

return a+b+c; /P треугольника/

} Double P (double a, double b, double c, double d)

{

return a+b+c+d /P четырехугольника/

}

Принцип работы перегруженных функций и методов

Перегружаемые функции имеют одинаковое имя, но разное количество или типы аргументов. При перегрузке вопрос о том, какую из функций вызвать, решается по списку её аргументов.

Перегруженная функция фактически представляет собой несколько разных функций, и выбор подходящей происходит на этапе компиляции. Компилятор работает не с именами функций, а их внутренними представлениями, которые существенно отличаются от используемых в программе. Эти имена содержат в себе скрытое описание типов аргументов. Компилятор не различает функции по типу возвращаемого значения. Поэтому для компилятора функции с различным списком аргументов – это разные функции, а с

одинаковым списком аргументов, но с разными типами возвращаемого значения - одинаковые. Для корректной работы программ последнего следует избегать.

Перегрузка унарных и бинарных операторов

Унарные и бинарные операторы перегружаются по-разному.

унарные - в самом классе (получается новый метод класса)

бинарные - как отдельная функция

бинарные операторы прописываются вне класса, так как результат необязательно записывается в один из операндов, а может записываться в некий третий объект

в унарных операторах результат записывается в тот же самый объект, для которого вызван оператор, поэтому унарный стоит отнести к методам класса.

Привести примеры:

Унарные: const Integer& operator++(Integer& i) { i.value++; return i; } const Integer& operator--(Integer& i) { i.value--; return i; } Бинарные: const Integer operator+(const Integer& left, const Integer& right)

{ return Integer(left.value + right.value); } Integer& operator+=(Integer& left, const Integer& right)

{ left.value += right.value; return left; }

9. Шаблон. Назначение. Синтаксис объявления и использования шаблонов функций и классов. Примеры. Принцип работы шаблонов. Вариации синтаксиса объявления и использования шаблонов.

10. Классификация языков. Преимущества и недостатки. Язык C и C++. Краткая история.

11. Строки в C и C++. Функции и методы работы со строками.

Чтобы иметь возможность использовать строки в C++, сначала нужно подключить директиву #include <string>. Как только это будет сделано, мы сможем определять переменные типа std::string.

Функции и методы:

1) std::getline() - чтобы извлечь полную строку ввода. Она принимает два параметра: первый – std::cin, второй — переменная string:

std::getline(std::cin, string)

2) имя строки.length() - длина строки;

3) имя строки.size() – размер строки;

4) имя строки.empty() – вернёт true, если строка пустая;

5) имя строки.strcpy() - копирует содержимое одной строки в другую (в С)

6) имя строки.strcpy_s - копирует содержимое одной строки в другую, добавлен параметр для определения размера места назначения;

7) имя строки.strcat() — добавляет одну строку к другой (опасно);

8) имя строки.strncat() — добавляет одну строку к другой (с проверкой размера места назначения);

9) имя строки.strcmp() — сравнивает две строки (возвращает 0, если они равны);

10) имя строки.strncmp() — сравнивает две строки до определенного количества символов (возвращает 0, если они равны).

12. Файлы в C и C++. Функции и методы работы с файлами.

13. Структуры данных. Вектор (Array, vector). Назначение. Список (list). Назначение. Особенности. Словарь (map), его использование и назначение. Структуры стек (stack), дек (deque), очередь (queue).

Экзамен ЯПы
4. Функция. Назначение. Синтаксис объявления, определения и вызова. Принцип работы функции. Передача параметров по ссылке и по значению. Стек, пролог и эпилог функции. Адрес возврата.
Функция (в программировании) — это фрагмент кода или алгоритм, реализованный на каком-то языке программирования, с целью выполнения определённой последовательности операций. Итак, функции позволяют сделать программу модульной, то есть разделить программу на несколько маленьких подпрограмм (функций), которые в совокупности выполняют поставленную задачу. Еще один огромнейший плюс функций в том, что их можно многократно использовать. Данная  возможность позволяет многократно использовать один раз написанный код, что в свою очередь, намного сокращает объем кода программы! это именованный блок кода, который вызывается в нужных местах программы по имени. Другими словами, функция представляет собой подпрограмму, которую можно вызвать из основной программы, причем неоднократно. Повторяющийся (да и не только) блок программного кода обычно обозначают некоторым уникальным именем, чтобы потом при необходимости обратиться к нему по этому имени. Как видно, это простая и естественная идея, направленная на облегчение реализации сложных проектов, состоящих из более простых программ.
Плюсы использования функций
Давайте попробуем сформулировать плюсы использования функций у себя в программе:
•	Можно изменить только тело функции и при этом не понадобится искать ее вызов и изменять его, в отличии от использования кода без функций.
•	Большое уменьшение количества написания кода.

функция должна быть связана (интегрирована) с основной программой, так сказать, со своим внешним окружением. С целью обеспечения взаимодействия с остальной частью программы для функции можно предусмотреть так называемые вход и выход.
Вход в функцию — это передача ей аргументов - данных, полученных во внешней части программы. Получив данные из своего внешнего окружения (внешней программы), функция должна их как-то обработать: выполнить некоторые действия, вычислить какое-то значение. Выход из функции — значение, вычисленное блоком кода данной функции и передаваемое во внешнюю часть программы. Входные данные называют параметрами, а выходные — возвращаемым значением. Впрочем, функция может и не принимать никаких параметров, а также ничего не возвращать. Что принимает в качестве параметров и что возвращает функция в результате своей работы, определяет программист, т. е. автор-разработчик программного кода.
Функция, создаваемая разработчиком, должна иметь определение, а ее применение в программе называют вызовом функции.
Функция, создаваемая разработчиком, должна иметь определение, а ее применение в программе называют вызовом функции. такое определение начинается с ключевого слова function, за которым следуют имя функции, пара круглых скобок, внутри которых можно указать список параметров, а затем блок кода, заключенный в фигурные скобки:
funсtion имя_функции(список_парамeтров) {
	блок кода
}
Замечу попутно, что блок кода в фигурных скобках называют еще телом функции. В нем записывают выражения языка, которые функция должна выполнить, если будет вызвана из основной программы. Таким образом, само по себе определение функции в программе еще ничего не выполняет. Оно только указывает интерпретатору, что должно быть выполнено при обращении к данной функции.
Для вызова функции в том или ином месте программы указывают следующее выражение:
имя_функции(список_параметров)
Круглые скобки после имени функции записывают независимо от того, предусмотрены для нее входные параметры или нет. В программе вы можете один раз задать определение функции, а затем, по мере необходимости, вызывать ее столько раз, сколько требуется. Таким образом, вам не придется многократно воспроизводить в программе код тела функции.

Отсюда следует, что основная программа может содержать как определения, так и вызовы функций. В программе, содержащей вызовы функций, должны быть доступны их определения. Простейший, но не единственно возможный способ обеспечить это заключается в том, чтобы заключить определения функций в тот же программный код, в котором они где-то вызываются. Опытные программисты обычно размещают определения функций в одном месте, например, в конце или, наоборот, в начале программного кода.
Смотрим пример объявления функции:
1
2
3	/ / Объявление прототипа функции с двумя целыми параметрами
/ / функция принимает два аргумента и возвращает их сумму
int sum(int num1, int num2);

Определение функций
1
2
3
4	returnDataType functionName( dataType argName1, dataType argName2, ..., dataType argNameN)
{
	// тело функции
}
Рассмотрим определение функции на примере функции sum.
1
2
3
4
5	// определение функции, которая суммирует два целых числа и возвращает их сумму
int sum(int num1, int num2)
{
	return (num1 + num2);
}
В языках C и C++, функции не должны быть определены до момента их использования, но они  должны быть ранее объявлены. Но даже после всего этого, в конце концов, эта функция должна быть определена. После этого прототип функции и ее определение связываются, и эта функция может быть использована.
Если функция ранее была объявлена, она должна быть определена с тем же возвращаемым значением и типами данных, в противном случае, будет создана новая, перегруженная функция.  Заметьте, что имена параметров функции не должны быть одинаковыми.
1
2
3
4
5
6
7
8	// объявление функции суммирования
int sum(int, int);

// определение функции суммирования
int sum(int num1, int num2)
{
	return (num1 + num2);
}
Вызов функций
После того, как функция была объявлена и определена, её можно использовать, для этого её нужно вызвать. Вызов функции выполняется следующим образом:
1	funcName( arg1, arg2, ...  );
где,
•	funcName — имя функции;
•	arg1..2 — аргументы функции (значения или переменные)
Вызов функции выполняется записью её имени, а затем круглых скобочек (). Если функция принимает аргументы, то в круглых скобках передаются аргументы, в порядке, указанном в объявлении функции.
Кроме вызова функций из стандартных заголовочных файлов, в языке программирования С++ предусмотрена возможность создания собственных функций. В языке программирования С++ есть два типа функций:
1.	Функции, которые не возвращают значений
2.	Функции, возвращающие значение
Функции, не возвращающие значения, завершив свою работу, никакого ответа программе не дают. Рассмотрим структуру объявления таких функций.
1
2
3
4
5	// структура объявления функций не возвращающих значений
void /*имя функции*/(/*параметры функции*/) // заголовок функции
{
// тело функции
}
Строка 2 начинается с зарезервированного слова void — это тип данных, который не может хранить какие - либо данные.Тип данных void говорит о том, что данная функция не возвращает никаких значений. void никак по - другому не используется и нужен только для того, чтобы компилятор мог определить тип функции.После зарезервированного слова void пишется имя функции.Сразу за именем функции ставятся две круглые скобочки, открывающаяся и закрывающаяся.Если нужно функции передавать какие - то данные, то внутри круглых скобочек объявляются параметры функции, они отделяются друг от друга запятыми.Строка 2 называется заголовком функции.После заголовка функции пишутся две фигурные скобочки, внутри которых находится алгоритм, называемый телом функции.Разработаем программу, в которой объявим функцию нахождения факториала, причём функция не должна возвращать значение.
•	MVS
•	Code::Blocks
•	Dev - C++
•	QtCreator
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24	// struct_func.cpp: определяет точку входа для консольного приложения.

#include "stdafx.h"
#include <iostream>
using namespace std;

// объявление функции нахождения n!
void faktorial(int numb)// заголовок функции
{
	int rezult = 1; // инициализируем переменную rezult значением 1
	for (int i = 1; i <= numb; i++) // цикл вычисления значения n!
		rezult *= i; // накапливаем произведение в переменной rezult
	cout << numb << "! = " << rezult << endl; // печать значения n!
}

int main(int argc, char* argv[])
{
	int digit; // переменная для хранения значения n!
	cout << "Enter number: ";
	cin >> digit;
	faktorial(digit);// запуск функции нахождения факториала
	system("pause");
	return 0;
}
После того, как были подключены все необходимые заголовочные файлы, можно объявлять функцию нахождения факториала.Под объявлением функции подразумевается выбор имени функции, определение параметров функции и написание алгоритма, который является телом функции.После выполнения этих действий функцию можно использовать в программе.Так как функция не должна возвращать значение, то тип возвращаемых данных должен быть void.Имя функции — faktorial, внутри круглых скобочек объявлена переменная numb типа int.Эта переменная является параметром функции faktorial().Таким образом, все объявления в строке 8 в совокупности составляют заголовок функции.Строки 9 — 14 составляют тело функции faktorial().Внутри тела в строке 10 объявлена переменная rezult, которая будет хранить результат нахождения n!После чего, в строках 11 - 12 Объявлен оператор цикла for для нахождения факториала.В строке 13 объявлен оператор cout, с помощью которого значение факториала будет печататься на экране.Теперь, когда функция объявлена можно воспользоваться ею.В строке 21 запускается функция faktorial(digit), внутри скобочек функции передаётся аргумент, т.е.значение, содержащееся в переменной digit.Результат работы программы(см.Рисунок 1).
CppStudio.com
Enter number : 5
5!= 120
Для продолжения нажмите любую клавишу . . .
Рисунок 1 — Функции в С++
Итак, после запуска программы, было введена цифра 5, и программа вычислила, что значение 120 это 5!.
Функции, возвращающие значение, по завершению своей работы возвращают определённый результат.Такие функции могут возвращать значение любого типа данных.Структура функций, возвращающих значение будет немного отличатся от структуры функций рассмотренных ранее.
1
2
3
4
5
6	// структура объявления функций возвращающих значения
/*возвращаемый тип данных*/ /*имя функции*/(/*параметры функции*/) // заголовок функции
{
	// тело функции
	return /*возвращаемое значение*/;
}
Структура объявления функций осталась почти неизменной, за исключением двух строк.В заголовке функции сначала нужно определять возвращаемый тип данных, это может быть тип данных int, если необходимо возвратить целое число или тип данных float — для чисел с плавающей точкой.В общем, любой другой тип данных, всё зависит от того, что функция должна вернуть.Так как функция должна вернуть значение, то для этого должен быть предусмотрен специальный механизм, как в строке 5. C помощью зарезервированного слова return  можно вернуть значение, по завершении работы функции.Всё, что нужно, так это указать переменную, содержащую нужное значение, или некоторое значение, после оператора return.Тип данных возвращаемого значения в строке 5 должен совпадать с типом данных в строке 2. Переделаем программу нахождения факториала так, чтобы функция faktorial() возвращала значение факториала.

Передача параметров по ссылке и по значению
Параметры в функцию могут передаваться одним из следующих способов :
• по значению;
• по ссылке.
При передаче аргументов по значению компилятор создает временную копию объекта, который должен быть передан, и размещает ее в области стековой памяти, предназначенной для хранения локальных объектов.Вызываемая функция оперирует именно с этой копией, не оказывая влияния на оригинал объекта.Прототипы функций, принимающих аргументы по значению, предусматривают в качестве параметров указание типа объекта, а не его адреса.Например, функция
int GetMax(int, int);
принимает два целочисленных аргумента по значению.
Если же необходимо, чтобы функция модифицировала оригинал объекта, используется передача параметров по ссылке.При этом в функцию передается не сам объект, а только его адрес.Таким образом, все модификации в теле функции переданных ей по ссылке аргументов воздействуют на объект.Принимая во внимание тот факт, что функция может возвращать лишь единственное значение, использование передачи адреса объекта оказывается весьма эффективным способом работы с большим числом данных.Кроме того, так как передается адрес, а не сам объект, существенно экономится стековая память.
В C++ передача по ссылке может осуществляться двумя способами :
• используя непосредственно ссылки;
• с помощью указателей.
Синтаксис передачи с использованием ссылок подразумевает применение в качестве аргумента ссылки на тип объекта.Например, функция
double Glue(long& var1, int& var2);
получает две ссылки на переменные типа long и int.При передаче в функцию параметра - ссылки компилятор автоматически передает в функцию адрес переменной, указанной в качестве аргумента.Ставить знак амперсанда перед аргументом в вызове функции не нужно.
Стек(англ.stack — стопка; читается стэк) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO(англ.last in — first out, «последним пришёл — первым вышел»).
В стеке нет индексов, т.е.нельзя обратиться к определенному элементу.
Каждый элемент имеет указатель на следующий элемент.
Головной элемент указывает на NULL.

Я знаю, что данные во вложенных вызовах функций переходят в стек.Сам стек реализует пошаговый метод хранения и извлечения данных из стека, когда функции вызываются или возвращаются.Имя этих методов наиболее известно как Пролог и Эпилог.
Пролог - это то, что происходит в начале функции.Его обязанностью является создание фрейма стека вызываемой функции.Эпилог - это полная противоположность : это то, что происходит последним в функции, и его целью является восстановление фрейма стека вызывающей(родительской) функции.
Пролог функции обычно выполняет следующие действия, если архитектура имеет базовый указатель(также известный как указатель кадра) и указатель стека :
•	Помещает текущий базовый указатель в стек, чтобы его можно было восстановить позже.
•	Назначает значение указателя стека(который указывает на сохраненный базовый указатель) базовому указателю, так что новый кадр стека будет создан поверх старого кадра стека.
•	Перемещает указатель стека дальше, уменьшая или увеличивая его значение, в зависимости от того, увеличивается или уменьшается стек.На x86 указатель стека уменьшается, чтобы освободить место для локальных переменных функции.
пилог функции отменяет действия пролога функции и возвращает управление вызывающей функции.Обычно он выполняет следующие действия(эта процедура может отличаться в зависимости от архитектуры) :
	•	Удалите указатель стека на текущий базовый указатель, чтобы освободить место, зарезервированное в прологе для локальных переменных.
	•	Извлекает базовый указатель из стека, поэтому он восстанавливается до значения перед прологом.
	•	Возврат к вызывающей функции путем удаления счетчика программы предыдущего кадра из стека и перехода к нему.
	Возврат по адресу – это возврат адреса переменной обратно в caller.Подобно передаче по адресу, возврат по адресу может возвращать только адрес переменной.Не литерала и не выражения(они не имеют адресов).Поскольку при возврате по адресу просто копируется адрес из функции в caller, то этот процесс также очень быстрый.
	Когда использовать возврат по адресу :
при возврате динамически выделенной памяти;
при возврате аргументов функции, которые были переданы по адресу.
Когда не использовать возврат по адресу :
при возврате переменных, которые были объявлены внутри функции(используйте возврат по значению);
при возврате большой структуры или класса, который был передан по ссылке(используйте возврат по ссылке).

7. Библиотеки.Назначение.Примеры библиотек с открытым кодом.Типы связывания.Преимущества и недостатки различных типов.Статическое связывание.Неявное связывание динамических библиотек.Явное связывание динамических библиотек.

Стандартные C++ библиотеки представляют собой наборы функций, констант, классов, объектов и шаблонов, которые расширяют язык С++ предоставляя базовую функциональность для выполнения различных задач, таких как : классы для взаимодействия с операционной системой, контейнеры данных, манипуляторы для работы с этими данными и наиболее используемые алгоритмы.
Все элементы стандартных библиотек С++ распределены по различным заголовочным файлам, которые необходимо подключать к программе.
Благодаря тому, что все компоненты библиотеки представляют собой шаблоны, их можно использовать для любых типов элементов.Помимо этого библиотека позволяет строить собственные классы и алгоритмы, которые смогут работать совместно с уже имеющимися.

•	Хару - свободная кросс - платформа, библиотека программного обеспечения с открытым исходным кодом для создавая PDF, написанный в ANSI - C.Это может работать как статическая библиотека(.a, .lib) и shared - library(.so, DLL).

•	OpenGL
•	DynaPDF – удобный гибкий инструмент.Формат.dll
•	Ogre3D
•	IT++
•	openssl
•	crypto++
•	mysql++
•	libpqxx
•	sqlapi
•	SOCI
•	DTL

Типы связывания
ДИНАМИЧЕСКОЕ НЕЯВНОЕ
- ЕХЕ становится в зависимости от FLL в момент компиляции
- Требуется подклбчение небольшой lib(объемом гораздо меньще, чем при статическом), содержащей адреса на ф - йии в DLL
- DLL грузится в ОП в момент загрузки ЕХЕ, есди DLL не находится приложение выключается

ДИНАМИЧЕСКОЕ ЯВНОЕ
- Прилодение грузит DLL в память с помощью социальной ф - ции LoadLibrary()
- Переде вызовом ф - ции приложение должно сначала найти еe в DLL по строковому имени с помощью ф - ции прототип_функции
GetProcAddress(HINSTSNCE ссылка_на_загруженную_DLL, "имя_функции")
- Если DLL не найдена, приложение технически может продолжать работу, но без ф - ции из DLL

extern int func1(double p1, chsr p2) - прототип ф - ции, с помощью которого линковщик(компановщик) находит
саму ф - цию в подклбченном *.lib

неявное связывание : dll грузятся в ОП при запуске ехе.В случае динамического связывания к ехе все равно
подключается lib, но этот lib содержит не реализации самих ф - ций, а только таблицу адресовЮ где искать их в dll

extern "C"__declspec(dllimport) int fnc(double p1, char p2) - по этому объявлению компоновщик ищет адрес ф - ции в lib - таблице адресов

явное связывание - отдается специальная команда на подгрузку dll внутри приложения
typedef int(CALLBACK* FUNC2) (double, char) - прототип или объявление ф - ции - инструкция для компилятора в каком порядке и какого размера
передавать в стек параметры и какой ожидать выходной параметр

__stdcall - компилятор передает парметры в стек по порядку : p1, p2, p3
__cdecl - компилятор передает параметры в обратном порядке : p3, p2, p1
CALLBACK - псевдрним для__stdcall

ДВА ТИПА ПОДКЛЮЧЕНИЯ DLL К ПРИЛОЖЕНИЮ(статичсекое связывание, динамическое связывание)
статичсекое связывание : dll грузится в ОП сразу при запуске приложения при отсутствии dll происходит сбой приложение не работает
Также такой подход требует наличие трех файлов : саму готовую dll, header и промежкточный lib библиотеки, которая хранит для сборщика приложения
адреса используемых ф - ций в dll
дмнамическое подключение :
грузится не при запуске приложения, а  в тот момент, который определил программист в коде с помощбю мпецциальной ф - ции library
третий файл lib  с таблицей соответсвия не нужен, ф - ции внутри dll ищутся по имени getprocadres
преимущества :
1.третий файл lib  с таблицей соответсвия не нужен, ф - ции внутри dll ищутся по имени getprocadres
2.библиотека подклбчается по необходимости
недостатки :
1.усложняется работа с кодом приложения

10. Классификация языков.Преимущества и недостатки.Язык C и C++.Краткая история.

Классификация по степени автоматизации :
1.	Высокого уровня
2.	Низкого уровня
3.	Машинные коды
Машинные коды
Команды и данные вводятся сразу в бинарном виде, прямо в редакторе.Упрощённо говоря, машинная команда – последовательность нулей и единиц.Формируется файл, в который программистом непосредственно прописываются команды, данные, байт за байтом, в виде чисел, чаще всего в 16 формате при этом программист должен знать в тонкостях, как работает процессор, какие команды, в какой последовательности на какую ножку процессора необходимо направить
Круг пользователей :
• разработчики вычислительной техники(контроллеров, процессоров,
	периферии),
	• любители,
	• реверс - инженеры(включая специалистов инфобеза, взломщиков)
	Ассемблер
	Тот же самый машинный код, но для удобства программиста операторы языка обозначены текстовыми сокращениями ADD, CMP(compare), JMP(jump).
	Программа составляется в виде текстового файла, который затем переводится в машинные команды транслятором / компилятором.
	Пользователи ассемблера :
• разработчики вычислительной техники(контроллеров, процессоров, периферии),
• программисты встраиваемых систем и микроконтроллеров(даже сейчас не на каждый МК есть высокоуровневый компилятор),
• любители,
• реверс - инженеры(включая ИБ, взломщиков и пр.).
Машинные команды
- высокий объём работы
- длительность и дороговизна изучения изучения
- требует знаний не только языка, но и особенностей работы процессора
- отсутствие совместимости между платформами
- отсутствие контроля ошибок программиста
- непереносимость на другие аппаратные платформы
+ минимальный объём бинарника(exe / dll / elf)
+ наиболее непосредственное использование аппаратных возможностей

Ассемблер
Те же « + » и « - », что и для машинных кодов, но
+ чуть большее удобство благодаря текстовым обозначениям
+ контроль ошибок программиста(минимальный)
+ по сравнению с языками высокого уровня, транслятор с ассемблера
отличается простотой
Языки программирования низкого уровня Преимущества :
С помощью языков низкого уровня создаются эффективные и компактные программы, поскольку разработчик получает доступ ко всем возможностям процессора.
Недостатки :
	•	Программист, работающий с языками низкого уровня, должен быть высокой квалификации, хорошо понимать устройство микропроцессорной системы, для которой создается программа.Так, если программа создается для компьютера, нужно знать устройство компьютера и, особенно, устройство и особенности работы его процессора.
	•	результирующая программа не может быть перенесена на компьютер или устройство с другим типом процессора.
	•	значительное время разработки больших и сложных программ.
	Языки низкого уровня, как правило, используют для написания небольших системных программ, драйверов устройств, модулей стыков с нестандартным оборудованием, программирование специализированных микропроцессоров, когда важнейшими требованиями являются компактность, быстродействие и возможность прямого доступа к аппаратным ресурсам.
	Языки программирования высокого уровня
	Можно сказать более понятными человеку, чем компьютеру.Действие программиста автоматизировано, нет необходимости прописывать все слова.одной команде может соотвествовать целая цепочка низкоуровневых команд Разрабатывать программы на таких языках гораздо проще и ошибок допускается меньше.Значительно сокращается время разработки программы, что особенно важно при работе над большими программными проектами.
	Плюсы:
1.	Наиболее быстрая и легкая разработка.Быстрая подготовка специалиста.
2.	Компилятор проверяет ошибки
3.	Относительная платформонезависимость
Недостатком языков высокого уровня является больший размер программ по сравнению с программами на языке низкого уровня.Поэтому в основном языки высокого уровня используются для разработок программного обеспечения компьютеров и устройств, которые имеют большой объем памяти.А разные подвиды ассемблера применяются для программирования других устройств, где критичным является размер программы.
Минус :
	Требует разработки сложных инструментов под каждую платформу(компиляторы)
	языки высокого уровня : Паскаль(Pascal), Си(С++), Джава(Java / Java Script), pyton, basic, Матлаб(Matlab), Php, язык разметки Html.

	Классификация по характеру трансляции
	Компилируемые, интегрируемы, виртуальные языки
	1.компилируемые
	Текст написанный разработчиком преоьразуется в бинарный файл один раз(при компиляции), конечный пользователь пользуется бинарным кодом
	Плюсы
	1.	Защита текста интеллектуальной собственности разраба
	2.	Наиболее высокая производительность
	Минусы :
1.	Отсутствие бинарной совместимости и переносимости
2.интегрируемые
Программа передается конечному пользователю в виде текста в его рабочей среде отдельной программой - интерпритатором - строчка за строчкой и выполняется шаг за шагом
Плюсы :
2.	Более высокая переносимость
3.	Возможность модификации кода пользователями
4.	Возможность исполнения части программы
Минусы
1.	Сниженная примерно в 100 раз производительность
3.виртуальные
Java, Scala
Текст->байт код->платформа пользователя->CPU
Плюсы
1. Защита интеллектуальной собственности
2.	Работает быстрее интерпретируемых языков, но примерно в 2 раза медленнее компилируемых
3.	Высокая переносимость программ

Классификация по работе с данными

1.	Статически типизируемые
2.	Динамически типизируемые

Краткая история С / С++

Си
Разработал инженер фирмы Bell Labs язык С - Деннис Ритчи
Первоначально язык очень высокой инженерной направленности, год выпуска примерно 1969 - 1685

Язык С++ как развитие С, был создан в 1979г.Бьярни Страуструпом, который в то время начал работать в Bell Labs.Разработка и усовершенствование языка С++ потребовали от создателя больших усилий на протяжении 80 - х и большей части 90 - х годов.

C++84
ANSI C++ / ISO C++
C++ 99
C++ 11 (+boost)
C++ 14
C++ 17 (+boost)

Говоря в самых общих словах, язык С++ является объектно - ориентированной, усовершенствованной версией языка С.Несмотря на то, что язык С++ был задуман как набор объектно - ориентированных расширений для языка С, вскоре он развился в самостоятельный язык программирования.

13.Структуры данных.Вектор(Array, vector).Назначение.Список(list).Назначение.Особенности.Словарь(map), его использование и назначение.Структуры стек(stack), дек(deque), очередь(queue)
Структура — это, некое объединение различных переменных(даже с разными типами данных), которому можно присвоить имя.Например можно объединить данные об  объекте Дом : город(в котором дом находится), улица, количество квартир, интернет(проведен или нет) и т.д.в одной структуре.В общем, можно собрать в одну совокупность данные обо  всем, что угодно, точнее обо  всем, что необходимо конкретному программисту.
структура может содержать несколько переменных типа int и несколько переменных типа char.Переменные, которые содержаться в структуре называются членами или полями структуры.Структуры можно определять с помощью ключевого слова struct.
Пример описания структуры :
struct student
{
	char name[50];
	int kurs;
	int age;
};


Вектор — это структура данных, которая уже является моделью динамического массива.
Как создать вектор(vector) в C++
Сначала для создания вектора нам понадобится подключить библиотеку — <vector>, в ней хранится шаблон вектора.
#include <vector>

чтобы объявить вектор
vector<тип данных><имя вектора>
После имени вектора ставим знак равенства и скобки, в которых через пробел указываем значение элементов.
… = { “c”,” + ”,” + ” }
Доступ к элементам
Доступ к отдельному элементу вектора можно получить, используя операции, описанные в таблице ниже.По соглашению C и C++, первый элемент имеет индекс 0, последний — size()
Выражение	Возвращаемый тип	Проверка границы ?
v.at(i)	T& или const T&для элемента i	Возможен выброс исключения out_of_range
v[i]	T& или const T&для элемента i	Неопределенное поведение при i >= v.size()
v.front()	T& или const T&для первого элемента	Неопределенное поведение при v.empty() == true
v.back()	T& или const T&для последнего элемента	Неопределенное поведение при v.empty() == true

std::array — это фиксированный массив, который не распадается в указатель при передаче в функцию.std::array определяется в заголовочном файле <array>, внутри пространства имен std.
Объявление такого массива : std::array<тип_данных, кол - во элементов> имя массива(std::array<int, 4> t)
Что такое список list
Это структура данных, которая построена на двусвязных списках.Это значит, что любой элемент знает только о предыдущем и о следующем элементах.
На картинке ниже показана, как это устроено :

У двусвязного списка нет индексов, но вместо их в C++ есть итераторы.
i_am_list[2] = 8
Программисты используют этот контейнер из - за быстрого добавления и удаление значений.Это происходит так быстро, потому что не приходиться перемещать элементы между собой, нужно лишь правильно манипулировать указателями.
На примере выше в начале было два элемента, потом мы решили добавить один элемент между ними.

А так совершается удаление.
Как создать список list
Сначала подключаем библиотеку — <list> .
#include <list>
List <тип данных><имя контейнера>
•	< тип данных > — сюда мы должны указать тип, который хотим использовать.
•	<имя контейнера> — это будет нашим именем контейнера.Лучше указывать такое имя, которое будет говорить, за что этот контейнер отвечает.
тобы сразу после создания списка присвоить ему значения нужно сделать так :
list<int> this_list = { 4, 6, 3, 2 }

Методы списка list
Вот функции которые можно применять в своей программе вместе со списком(нажмите на их имена чтобы перейти на страницу с полным руководством) :
	Имя функции	Описание
	pop_front	удалить элемент в начале
	pop_back	удалить элемент в конце
	push_front	добавить элемент в начала
	push_back	добавить элемент в конец
	front	обратится к первому элементу
	back	обратиться к последнему элементу
	insert	добавить элемент в какое - то место
	copy
	вывести все элементы списка(и не только)
	unique	удалить все дубликаты
	merge	добавление другого списка

	insert
	С помощью его можно добавить новый элемент в любую часть контейнера(в нашем случае для списка).Вот как он работает :
insert(<позиция>, <значение>);
•	Первым аргументом передаем — местоположение.Оно указывается итератором, что это читайте вот здесь.
•	Вторым значение новой ячейки.Здесь может быть как переменная так и просто значение(5 например).
String cpp = “…”;
insert(it, cpp);

copy
Вообще он имеет несколько видов применения :
•	Вывод элементов.
•	Запись элементов.
•	А также копирования какого - то количества ячеек и вставка их в позицию Y.
Чтобы его использовать дополнительно нужно подключить библиотеку — <iterator>.
Ввод :

	copy(myspisok.begin(), myspisok.end(), ostream_iterator<int>(cout, ””));
Первые два значения(myspisok.begin(), myspisok.end()) которые должны передать, — это итераторы начала и конца контейнера.
Дальше используем итератор вывода — ostream_iterator<int>(cout, " ").В кавычках указывается значение между элементами(в нашем случае это пробел).

unique
Удаляет все повторяющиеся элементы(дубликаты).Использовать его очень просто :
myspisok.unique();

merge
Добавляет существующему списку еще один.
myspisok.merge(dob_spisok);

Контейнер map, очень похож на остальные контейнеры, такие как vector, list, deque, но с небольшим отличием.В этот контейнер можно помещать сразу два значения.Все данные хранятся в виде пар ключ - значение.Доступ к элементам данных осуществляется по ключу.Ключ всегда должен быть уникальным в пределах одного словаря, данные могут дублироваться при необходимости.У данной структуры есть и другие часто встречающиеся названия : ассоциативный массив или Dictionary.Принцип работы словаря схож с камерой хранения : есть ячейка, в которой может храниться что угодно, но доступ к этой ячейке осуществляется по уникальному номеру, благодаря чему ее всегда легко найти.
Особенности :
	1.	Ключом может быть все что угодна.От обычной переменной до класса.
	mp1[0] = 7;//ключ-число
mp2[“zero”] = 4;//ключ-строка
pair<int, int>p = make_pair(1, 3);
mp3[p] = 3;//ключ-пара
2.	При добавлении нового элемента контейнер будет отсортирован по возрастанию.
Ключом в нашем случае будет — русское слова.
А значением — английское.
Map<string, string> mp;
Mp[“привет”] = ”hi”;

Как создать map
Сперва понадобится подключить соответствующую библиотеку :
#include<map>
Чтобы создать map нужно воспользоваться данной конструкцией :
Map << L > , <R >> <имя>;
•	<L> — этот тип данных будет относиться к значению ключа.
•	<R> — этот тип данных соответственно относится к значению.

Mp<string, int>mp
В нашем случае :
•	Ключ — строка.
•	Значение — число.
Итераторы для map
Использование итераторов одна из главных тем, если вам понадобится оперировать с этим контейнером.Создание итератора, как обычно происходит так :
Map<тип данных>::iterator<имя>;
•	<тип данных> — <string, int> например.
С помощью его можно использовать две операции(it — итератор) :
	1.	Чтобы обратится к ключу нужно сделать так : it->first.
	2.	Чтобы обратится к значению ячейки нужно сделать так : it->second.
	Методы map
	Ниже мы разберем функции которые можно использовать для работы с map.
	•	insert
	•	count
	•	find
	•	erase
	insert
	Это функция вставки нового элемента.
	Mp.insert(make_pair(num_1, num_2));
•	num_1 — ключ.
•	num_2 — значение.
count
Возвращает количество элементов с данным ключом.В нашем случае будет возвращать — 1 или 0.
Mp[0] = 0;
Mp.cout(0);
Mp.cout(3);
find
У этой функции основная цель узнать, есть ли определенный ключ в контейнере.
•	Если он есть, то передать итератор на его местоположение.
•	Если его нет, то передать итератор на конец контейнера.

Стек — это структура данных, которая работает
по принципу FILO(first in — last out; первый пришел — последний ушел).


В стеке нет индексов, т.е.нельзя обратиться к определенному элементу.
Каждый элемент имеет указатель на следующий элемент.
Головной элемент указывает на NULL.

Достоинство: операции удаления и добавления элемента делаются за const время.
	std::stack<int> stackInt;//stack <тип данных> <имя>; -создание стека
int i = 0, a = 0;
std::cout << "Введите 5 целых чисел:  " << std::endl;
while (i != 5) {
	std::cin >> a;
	deque.push_back(a);
	deque.push_front(a);
	//stackInt.push(a);  добавляем введенное число
	i++;
}

if (deque.empty()) // проверяем пуст ли стек (нет)
std::cout << "Стек не пуст";

std::cout << "Верхний элемент стека:" << stackInt.top() << std::endl;
stackInt.pop(); // удаляем верхний элемент
*/
//system("pause");
//return 0;
Как создать стек в C++
Для использования шаблона стека в начале нашей программе мы должны подключить библиотеку — <stack>.
Чтобы создать стек нам понадобится оперировать схемой ниже :
Stack<тип данных><имя>;
•	С новой строки мы должны написать слова stack.
•	<тип данных> — здесь нам понадобиться написать тот тип данных, который будет храниться в стеке.
•	<имя> — здесь вам все должно быть понятно.

Очередь — это структура данных, которая построена по принципу
LILO(last in — last out : последним пришел — последним вышел).
Как создать очередь в С++
Если вы хотите использовать шаблон очереди в C++, то вам сначала нужно подключить библиотеку — <queue>.
Дальше для объявления очереди нужно воспользоваться конструкцией ниже.
Queue<тип данных><имя>;
Queue<int> q;
•	Сначала нам нужно написать слова queue.
•	Дальше в <тип данных> мы должны указать тот тип, которым будем заполнять нашу очередь.
•	И в конце нам остается только указать название очереди.

Методы очереди
Для работы с очередью вам понадобится знать функции : push(), pop(), front(), back(), empty().Кстати, если хотите узнать, как в C++ работают функции и как их правильно использовать в проекте, то можете узнать все это здесь.
1.	Для добавления в очередь нового элемента нужно воспользоваться функцией — push().В круглых скобках должно находится значение, которое мы хотим добавить.
2.	Если нам понадобилось удалить первый элемент нужно оперировать функцией pop().В круглых скобках уже не чего не нужно указывать, но по правилам они в обязательном порядке должны присутствовать!Эти функции тоже не нуждаются в указании аргумента : empty(), back() и front().
3.	Если вам понадобилось обратиться к первому элементу очереди, то вам понадобится функция front().
4.	Чтобы обратиться к последнему элементу в очереди вам поможет функция back().
5.	Чтобы узнать пуста ли очередь нужно воспользоваться функцией empty().
o	Если ваша очередь пуста — возвратит true.
o	Если же в ней что - то есть — возвратит false.
Очередь с приоритетом
Очередь с приоритетом(priority_queue) — это обычная очередь, но в ней новый элемент добавляется в то место, чтобы очередь была отсортирована по убыванию.
Так самый большой элемент в приоритетной очереди будет стоять на первом месте.
Для объявления шаблона очереди с приоритетом нужно использовать конструкцию ниже :
Priority_queue<тип данных><имя>;
•	В начале нужно написать priority_queue.
•	Потом в скобках указать тип данных, который будет находится в очереди.
•	И конечно же в самом конце мы должны дать ей имя.
Для добавления элемента в очередь с приоритетом мы должны использовать функцию push().Но чтобы обратится к первому элементу должны использоваться именно функция — top() (как и в стеке).А не функция — front().
Также нельзя использовать функцию back() для обращения к последнему элементу.Для приоритетной очереди она также не работает, как функция front().



/*
std::queue <int> MyQueue; // создали очередь
std::cout << "Введите 7 чисел: " << std::endl;
for (i = 0; i < 7; i++) {
	std::cin >> a;
	MyQueue.push(a); // добавляем в очередь элементы
}
std::cout << std::endl;
std::cout << "Первый элемент в очереди: " << MyQueue.front() << std::endl;
MyQueue.pop(); // удаляем элемент из очереди
std::cout << "Первый элемент (после удаления): " << MyQueue.front() << std::endl;

if (!MyQueue.empty()) // проверяем пуста ли очередь (нет)
	std::cout << "Очередь не пуста!";
	*/
	/*
Очередь с приоритетом (priority_queue) — это обычная очередь,
но в ней новый элемент добавляется в такое место,
чтобы очередь была отсортирована по убыванию.
*/
/*
	std::priority_queue <int> priority_q; // объявляем приоритетную очередь

	std::cout << "Введите 7 чисел: " << std::endl;
	for (i = 0; i < 7; i++) {
		std::cin >> a;
		priority_q.push(a); // добавляем элементы в очередь
	}
	// выводим первый
	std::cout << "Первый элемент очереди: " << priority_q.top();
	*/




	Билет №3
	1.	Операторы цикла(3 разновидности) и условного перехода(2 разновидности).Синтаксис операторов. +

	Операторы цикла

	Цикл с предусловием(while)

	while (выражение) оператор

		Выражение определяет условие повторения тела цикла, представленного простым или составным оператором.Выполнение цикла начинается с вычисления выражения.Если оно истинно(не равно false), выполняется оператор цикла.Если при первой проверке выражение равно false, цикл не выполнится ни разу.Тип выражения должен быть арифметическим или приводимым к нему.Выражение вычисляется перед каждой итерацией цикла.Когда выражение оказывается ложным, управление передается следующему после цикла оператору.
		Тело цикла может состоять не из одного оператора, а представлять собой блок.
		Пример(программа находит все делители целого положительного числа) :
		Для краткости изложения начало всех программ этой главы не приводится, но подразумевается

		int num;
cout << RUS("\nВведите число : "); cin >> num;
int div = 2; // кандидат на делитель
while (div <= num)
{
	if (!(num % div))cout << div << "\n";
	div++;
}

Цикл с постусловием(do … while)

do оператор while (выражение);

Сначала выполняется оператор или блок, составляющий тело цикла, а затем вычисляется выражение.Если оно истинно(не равно false), тело цикла выполняется еще раз.Цикл завершается, когда выражение станет равным false или в теле цикла будет выполнен какой - либо оператор передачи управления.Тип выражения должен быть арифметическим или приводимым к нему.
Пример(программа осуществляет проверку ввода) :

	char answer;
do { cout << RUS("\nКупи слоника! "); cin >> answer; } while (answer != 'y');

Цикл с параметром for

for (инициализация; выражение; модификации) оператор;

Инициализация используется для объявления и присвоения начальных значений величинам, используемым в цикле.В этой части можно записать не - сколько операторов, разделенных запятой(операцией «последовательное выполнение»), например, так:

for (int i = 0, j = 2; ...
	или
	int k, m:
for (k = 1, m = 0; ...

	Операторы условного перехода

	Условный оператор if
	Для организации вычислений в зависимости от какого - либо условия в C++ предусмотрен условный оператор if, который в общем виде записывается следующим образом :
if (условие) оператор_1; else оператор_2;
Здесь условие — это логическое выражение, переменная или константа.
Работает условный оператор следующем образом.Сначала вычисляется значения выражения, записанного в виде условия.Если оно имеет значение истина(true), выполняется оператор_1.В противном случае(значение ложное(false)) оператор_2.

Если в задаче требуется, чтобы в зависимости от значения условия выполнялся не один оператор, а несколько, их необходимо заключить в фигурные скобки, как составной оператор.
if (условие) { оператор_1; оператор_2; … }
else { оператор_1; оператор_2; … }
Альтернативная ветвь else в условном операторе может отсутствовать, если в ней нет необходимости.

Он необходим в тех случаях, когда в зависимости от значений переменной надо выполнить те или иные операторы :
switch (выражение)
{
case значение_1: операторы_1; break;
case значение_2: операторы_2; break;
	…
case значение_n: операторы_n; break;
default: операторы; break;
}
Оператор работает следующем образом.Вычисляется значение выражения.Затем выполняются операторы, помеченные значением, совпадающим со значением выражения.То есть если, выражение принимает значение_1, то выполняются операторы_1 и т.д..Если выражение не принимает ни одного из значений, то выполняются операторы, расположенные после слова default.

Оператор break необходим для того, чтобы осуществить выход из оператора switch.Если он не указан, то будут выполняться следующие операторы из списка, несмотря на то, что значение, которым они помечены, не совпадает со значением выражения.

Синтаксис операторов
•	Пустой оператор –;
Пустой оператор – это оператор, состоящий только из точки с запятой.Он может появиться в любом месте программы, где по синтаксису требуется оператор.Выполнение пустого оператора не меняет состояния программы.
•	Составной оператор –{ ... }
Действие составного оператора состоит в последовательном выполнении содержащихся в нем операторов, за исключением тех случаев, когда какой - либо оператор явно передает управление в другое место программы.
•	Оператор обработки исключений

•	  try { <операторы> }
•	  catch (<объявление исключения>) { <операторы> }

2.	Операторы перехода на следующий цикл и прерывания цикла.Тернарный оператор. +
В теле любого цикла можно использовать операторы прерывания цикла - break и продолжения цикла - continue.

Оператор break позволяет выйти из цикла, не завершая его.
Оператор continue позволяет пропустить часть операторов тела цикла и начать новую итерацию.

Пример использования оператора continue:


for (int count = 0; count < 20; ++count)
{
	// если число делится нацело на 4, то пропускаем весь код в этой итерации после continue
	if ((count % 4) == 0)
		continue; // пропускаем всё и переходим в конец тела цикла
	// Если число не делится нацело на 4, выполнение кода продолжается
	cout << count << endl;
	// Точка выполнение после оператора continue перемещается сюда
}

Пример использования оператора break:

for (int count = 0; count <= 10; count++) // начало цикла for
{
	if (count == 6) // 
		break; // выход из цикла for
	cout << "2^" << count << " = " << pow(2.0, count) << endl; // печать степени двойки
}

Тернарный оператор.

Он используется обычно в тех случаях, если условие и код, который надо выполнить, в результате проверки условия, очень простые.К примеру, спросить у пользователя хочет он продолжить работать в программе или же хочет выйти из неё.Синтаксис такой :

"условие" ? "выражение 1" : "выражение 2";

Вначале надо  записать необходимое нам условие и за ним поставить знак вопроса ? .Далее, в этой же строке, после знака вопроса пишем первую простую команду(код), которая будет выполняться, если условие вернет истину(true).После этой команды ставим двоеточие : и пишем вторую команду(код).Эта вторая команда после двоеточия, выполнится только в том случае, если условие возвращает ложь(false).

Пример использования тернарного оператора :
Допустим пользователь снимает деньги в банкомате.Он провел эту операцию и на экране должен появиться вопрос : “Вы хотите выполнить другую операцию ? ”  Пользователю остается сделать выбор(да или нет) и нажать соответствующую кнопку.Организуем этот выбор в следующей программе :

bool variable = true;

cout << "Выполнение каких-то транзакций по счету карты...\n";
cout << "Вы хотите выполнить другую операцию (1 - да, 0 - нет)? ";
cin >> variable;

variable == 1 ? cout << "Выберите операцию!\n..........\n\n" : cout << "До свидания! Не забудьте взять чек!\n\n";

3.	Нестандартные варианты синтаксиса for и while. +
Нестандартные возможности цикла for:
1) Применение нескольких переменных управления циклом.

int a, b;
for (a = 0, b = 9; a < 10; ++a, --b)
	cout << a << " " << b << endl;

2) Отсутствие части цикла.

int count = 0;
for (; count < 10; )
{
	cout << count << " ";
	++count;
}

3) Бесконечный цикл.

int main() {
	int i = 0;
	for (;;) {
		i++;
		cout << i;
	}
	return 0;
}

Нестандартные возможности цикла while:

1) Бесконечный цикл.
int main() {
	int i = 0;
	while (true) {
		i++;
		cout << i;
	}
	return 0;
}



Билет №6
1.	Классы и объекты.Назначение.Синтаксис объявления, определения, доступа к свойствам и вызова методов.
Classes
Классы – абстрактные типы данных, которые создаются разработчиком программы.

Они сочетают в себе два функционала :
2.	Структура, в которой можно хранить различные типы данных : массивы, переменные, функции;
3.	Использование возможностей объектно - ориентированного программирования.

Внутреннее содержимое класса состоит из двух основных разделов :
Секция private содержит элементы, которые могут быть использованы только через секцию public.
Секция public содержит элементы образуют открытый интерфейс класса.дает публичный доступ, содержимому, которое в нем указано.Так можно обратится к любой переменной или функции из любой части программы.Зачастую здесь содержатся и прототипы функций.

Класс реализует основные положения ООП, такие как :
4.	Инкапсуляция — это возможность задавать разную область видимости определенной части класса.
5.	Наследование — это свойство создавать новый класс на базе старого.Такие классы называют потомками, например, есть класс магазин, на базе которого можно создать потомки продуктовый_магазин.
6.	Полиморфизм — возможность создать объекты с одинаковым интерфейсом, но с разной их реализацией.Например, есть три класса треугольник, круг и квадрат.У каждого из них есть метод SquarePlis(), который вычисляет площадь фигуры.Но для каждого класса функция реализована по - разному.
В языке программирования объект – это переменная типа «класс».Класс описывает данные и методы(функции), которые будут использоваться объектом этого класса.Каждый класс описывает логически - завершенную единицу программы.Инкапсуляция данных и методов их обработки в пределах класса позволяет улучшить структурированность программных систем.Это в свою очередь уменьшает риск возникновения «невидимых» логических ошибок.Использование наследственности и полиморфизма в классах позволяет избежать повторяемости программного кода и удобно упорядочить сложные вызовы методов, объединенных между собой в список.
Класс определяет формат(описание) некоторых данных и работу(поведение) над этими данными.Из объявления класса можно получить различное количество объектов класса(переменных типа «класс»).Каждый объект класса определяется конкретным(на данный момент) значением внутренних данных(переменных), которое называется состоянием объекта.
В классе объявляются данные(внутренние переменные, свойства) и методы(функции), которые оперируют этими данными(выполняют работу над данными).
Класс может быть унаследован от других классов верхних уровней.Это означает, что класс может использовать часть кода других классов верхних уровней.
Также класс может быть родительским для других классов, которые наследуют его программный код.
Определение класса и объекта
СВОЙСТВО(property) - переменная в составе класса
МЕТОД(method) - функция в составе класса
ИНКАПСУЛЯЦИЯ - фактически, объединение данных и методов, объединённых единым смыслом, в одну конструкцию языка
НАСЛЕДОВАНИЕ - создание производных классов от родительского и заимствование его свойств и методов
ПОЛИМОРФИЗМ простыми словами : экземпляры одного класса ведут себя по - разному : инкапсуляция, наследование и полиморфизм - три основные идеи ООП


2. СИНТАКСИС ОБЪЯВЛЕНИЯ ОБЪЕКТА И ОБРАЩЕНИЯ К СВОЙСТВАМ И МЕТОДАМ
Имя_Класса объект1;
car.speed = 123;
объект1.свойство1 = 1;
объект1.метод3();

3. CПЕЦИФИКАТОРЫ ДОСТУПА
К полям(свойствам и методам), объявленным в разделе public:
	можно обращаться везде(и из методов класса, и снаружи, где виден объект)
		К полям private и protected можно обращаться только из методов самого класса.Различие между private и protected объясняется в следующей теме про наследование классов

		2.	Модификаторы доступа.Конструктор и деструктор. +
		Модификаторы доступа public и private
		Все свойства и методы классов имеют права доступа.По умолчанию, все содержимое класса является доступным для чтения и записи только для него самого.Для того, чтобы разрешить доступ к данным класса извне, используют модификатор доступа public.Все функции и переменные, которые находятся после модификатора public, становятся доступными из всех частей программы.
		Закрытые данные класса размещаются после модификатора доступа private.Если отсутствует модификатор public, то все функции и переменные, по умолчанию являются закрытыми(как в первом примере).
		Обычно, приватными делают все свойства класса, а публичными — его методы.Все действия с закрытыми свойствами класса реализуются через его методы.
		Начнем с того, что, когда мы создаем элементы(переменные) класса, мы не можем присвоить им значения в самом определении класса.Компилятор выдаст ошибку.Поэтому нам необходимо создавать отдельный метод(так называемую set - функцию) класса, с помощью которого и будет происходить инициализация элементов.При этом, если необходимо создать, к примеру, 20 объектов класса, то чтобы инициализировать элементы потребуется 20 раз вызвать set - функции.
		Тут нам как раз сможет помочь конструктор класса.Кстати, конструктор(от слова construct — создавать) – это специальный метод класса, который предназначен для инициализации элементов класса некоторыми начальными значениями.
		В отличии от конструктора, деструктор(от слова destruct — разрушать) — специальный метод класса, который служит для уничтожения элементов класса.Чаще всего его используют тогда, когда в конструкторе, при создании объекта класса, динамически был выделен участок памяти и необходимо эту память очистить, если эти значения уже не нужны для дальнейшей работы программы.
		Важно запомнить :
	•	конструктор и деструктор, мы всегда объявляем в разделе public;
	•	при объявлении конструктора, тип данных возвращаемого значения не указывается, в том числе — void!!!;
	•	у деструктора также нет типа данных для возвращаемого значения, к тому же деструктору нельзя передавать никаких параметров;
	•	имя класса и конструктора должно быть идентично;
	•	имя деструктора идентично имени конструктора, но с приставкой ~;
	•	В классе допустимо создавать несколько конструкторов, если это необходимо.Имена, согласно пункту 2 нашего списка, будут одинаковыми.Компилятор будет их различать по передаваемым параметрам(как при перегрузке функций).Если мы не передаем в конструктор параметры, он считается конструктором по умолчанию;
	•	Обратите внимание на то, что в классе может быть объявлен только один деструктор

		3.	Наследование.Назначение.Синтаксис.Множественное наследование.Указатель this и каким образом он передаётся в методы классов.
		Наследование это принцип создания класса на базе уже существующего, при этом у нас есть возможность пользоваться функционалом(свойствами и методами) базового..Таким образом экономится масса времени на написание и отладку кода новой программы.Объекты производного класса  свободно могут использовать всё, что создано и отлажено в базовом классе.При этом, мы можем в производный класс, дописать необходимый код для усовершенствования программы : добавить новые элементы, методы и т.д..Базовый класс останется нетронутым.

		Классы созданные таким образом называются производными или дочерними, а на базе которого создаются — родителем или базовым.

		Синтаксис наследования такой —

		class Имя_Производного_Класса : спецификатор доступа Имя_Базового_Класса {  };

Двоеточие:  не путать с двойным двоеточием :: (определение области действия).Используя этот оператор мы показываем, наследником какого класса является производный класс.

	Множественное наследование позволяет порожденному классу наследовать элементы более, чем от одного базового класса.Синтаксис заголовков классов расширяется так, чтобы разрешить создание списка базовых классов и обозначения их уровня доступа :

			class X { ... };
			class Y { ... };
			class Z { ... };
			class A : public X, public Y, public Z { ... };

			Указатель this:

			В методы класса, неявно передается в виде параметра указатель this (указатель на объект класса).Происходит это автоматически.Мы этого не видим, так как этот указатель – есть скрытый первый параметр любого метода класса.Указатель this хранит адрес определённого объекта класса.

				В большинстве случаев нам не нужно обращаться к нему напрямую, но при необходимости это можно сделать.Стоит отметить, что this является константным указателем — вы можете изменить значение исходного объекта, но вы не можете указать this указывать на что - то другое.
				Билет №9
				1.	Шаблон.Назначение.Синтаксис объявления и использования шаблонов функций и классов.Примеры. +

				Шаблоны — средство языка C++, предназначенное для кодирования обобщённых алгоритмов, без привязки к некоторым параметрам(например, типам данных, размерам буферов, значениям по умолчанию).

				Шаблоны функций, своими словами — это инструкции, согласно которым создаются локальные версии шаблонированной функции для определенного набора параметров и типов данных.

				Любой шаблон начинается со слова template, будь то шаблон функции или шаблон класса.После ключевого слова template идут угловые скобки — < >, в которых перечисляется список параметров шаблона.Каждому параметру должно предшествовать зарезервированное слово class или typename.Отсутствие этих ключевых слов будет расцениваться компилятором как синтаксическая ошибка.

				Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип данных, такой как : int, double, float, char и т.д.А ключевое слово class сообщает компилятору, что в шаблоне функции в качестве параметра будут использоваться пользовательские типы данных, то есть классы.

				Пример 1

				template <typename T>
			class Name
			{
				//тело шаблона класса
			};

			T - это параметр шаблона класса, который может принимать любой из встроенных типов данных(int, double, float, char и т.д.)

				Пример 2

				Простейшим примером служит определение минимума из двух величин.
				Если a меньше b то вернуть а, иначе — вернуть b.
				В отсутствие шаблонов программисту приходится писать отдельные функции для каждого используемого типа данных.
				Так выглядит шаблон функции определения минимума :
			Template <typename T>
				T min(T a, T b) {
				return a < b ? a : b;
			}
			2.	Принцип работы шаблонов.
				3.	Вариации синтаксиса объявления и использования шаблонов. +

				Некоторые примеры объявления шаблонов :
			template <class T>
			или
				template <typename T>
			или
				template <typename T1, typename T2>


			Билет №12
				Файлы в C и C++.Функции и методы работы с файлами. +
				Когда поток открывается для ввода - вывода, он связывается со стандартной структурой типа FILE, которая определена в stdio.h.Структура FILE содержит необходимую информацию о файле.

				Открытие файла осуществляется с помощью функции fopen(), которая возвращает указатель на структуру типа FILE, который можно использовать для последующих операций с файлом.

				FILE *fopen(name, type);

			name – имя открываемого файла(включая путь),
				type — указатель на строку символов, определяющих способ доступа к файлу :
			•	"r" — открыть файл для чтения(файл должен существовать);
			•	"w" — открыть пустой файл для записи; если файл существует, то его содержимое теряется;
			•	"a" — открыть файл для записи в конец(для добавления); файл создается, если он не существует;
			•	"r+" — открыть файл для чтения и записи(файл должен существовать);
			•	"w+" — открыть пустой файл для чтения и записи; если файл существует, то его содержимое теряется;
			•	"a+" — открыть файл для чтения и дополнения, если файл не существует, то он создаётся.

				Функция fclose() закрывает поток или потоки, связанные с открытыми при помощи функции fopen() файлами.Закрываемый поток определяется аргументом функции fclose().


				Неформатированные файловый ввод - вывод
				Запись в файл
				fwrite(адрес записываемой величины, размер одного экземпляра, количество записываемых величин, имя логического файла);
			Например,
				fwrite(&dat, sizeof(int), 1, f);
			Чтение из файла
				fread(адрес величины, размер одного экземпляра, количество считываемых величин, имя логического файла);
			Например,
				fread(&dat, sizeof(int), 1, f);
			Закрытие файла
				fclose(имя логического файла);

			Форматированный файловый ввод - вывод
				1) Функции fgetc() и fputc() позволяют соответственно осуществить ввод - вывод символа.
				2) Функции fgets() и fputs() позволяют соответственно осуществить ввод - вывод строки.
				3) Функции fscanf() и fprintf() позволяют соответственно осуществить форматированный ввод - вывод и аналогичный соответствующим функциям форматированного ввода - вывода, только делают это применительно к файлу.


				Для работы с файлами используются специальные типы данных, называемые потоками.Поток ifstream служит для работы с файлами в режиме чтения, а ofstream в режиме записи.Для работы с файлами в режиме как записи, так и чтения служит поток fstream.
				В программах на C++ при работе с текстовыми файлами необходимо подключать библиотеки iostream и fstream.
				Для того чтобы записывать данные в текстовый файл, необходимо:
			1.	описать переменную типа ofstream.
				2.	открыть файл с помощью функции open.
				3.	вывести информацию в файл.
				4.	обязательно закрыть файл.
				Для считывания данных из текстового файла, необходимо :
				1.	описать переменную типа ifstream.
				2.	открыть файл с помощью функции open.
				3.	считать информацию из файла, при считывании каждой порции данных необходимо проверять, достигнут ли конец файла.
				4.	закрыть файл.
				Запись информации в текстовый файл
				Как было сказано ранее, для того чтобы начать работать с текстовым файлом, необходимо описать переменную типа ofstream.Например, так:
			ofstream F;
			Будет создана переменная F для записи информации в файл.На следующим этапе файл необходимо открыть для записи.В общем случае оператор открытия потока будет иметь вид :
			F.open(«file», mode);
			Здесь F — переменная, описанная как ofstream, file — полное имя файла на диске, mode — режим работы с открываемым файлом.Обратите внимание на то, что при указании полного имени файла нужно ставить двойной слеш.Для обращения, например к файлу accounts.txt, находящемуся в папке sites на диске D, в программе необходимо указать : D:\\sites\\accounts.txt.
				Файл может быть открыт в одном из следующих режимов :
			•	ios::in — открыть файл в режиме чтения данных; режим является режимом по умолчанию для потоков ifstream;
			•	ios::out — открыть файл в режиме записи данных(при этом информация о существующем файле уничтожается); режим является режимом по умолчанию для потоков ofstream;
			•	ios::app — открыть файл в режиме записи данных в конец файла;
			•	ios::ate — передвинуться в конец уже открытого файла;
			•	ios::trunc — очистить файл, это же происходит в режиме ios::out;
			•	ios::nocreate — не выполнять операцию открытия файла, если он не существует;
			•	ios::noreplace — не открывать существующий файл.

