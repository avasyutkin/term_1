// Lab_14.5 - работа с контейнером set

#include "pch.h"
#include <iostream>
#include <ctime>
#include <set>

using namespace std;

int main() {
	setlocale(LC_ALL, "Russian");
	srand(time(NULL));

	set <int> mst; //создали set

	cout << "Добавление случайных значений: " << endl; //заполняем его случайными числами
	for (int i = 0; i < 10; i++) {
		int random = rand() % 10 + 1;
		mst.insert(random);
		cout << i + 1 << ") " << random << endl;
	}

	set <int> ::iterator it = mst.begin();

	cout << "Отсортированный вариант: " << endl; 
	for (int i = 1; it != mst.end(); i++, it++) { //сравнивали итераторы на неравенство (!=), чтобы не выйти за диапазон значений контейнера и в последствии чтобы этот цикл не выполнялся бесконечно.
		cout << *it << " ";
	}

	system("pause");
	return 0;
}

//set — это контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, set будет хранить только один его экземпляр. По другому его еще называют множеством.
//создание set < [тип] > <имя>;
//set <int> st; пример
//Чтобы добавить новый элемент нужно использовать функцию insert()
//st.insert(<значение>);
//содание итератора 
//set < [тип] > :: iterator it;
//Чтобы итератор работал на определенный set [тип] должен совпадать с типом контейнера.
/*
copy
copy([начала], [конец], ostream_iterator<[тип] >(cout, [отступ]));
[начала] — итератор указывающий на первый элемент, который мы хотим вывести.Так мы можем начать выводить со второго или третьего элемента.
[конец] — итератор указывающий на ячейку, до которой будет производиться вывод.
[тип] — тип данных выводимых элементов(тип контейнера).
<отступ> — здесь можно указать, что выводить между элементами.Обычно указывают пробел(cout, " ").

erase
С помощь нее можно:
Удалить какой-то конкретный элемент — <имя>.erase([итератор])
Либо удалить определенный диапазон значений
<имя>.erase([начала], [конец]);
[начала] — с какого элемента будет происходить удаление (включительно).
[конец] — до какого элемента будет продолжаться (не включительно).
*/